<!DOCTYPE html>
<meta charset="utf8">
<pre class="metadata">
title: JavaScript Structs
stage: 1
contributors: Shu-yu Guo
markEffects: true
</pre>

<emu-intro id="intro">
  <h1>Structs, Shared Structs, Unsafe Blocks, and Synchronization Primitives</h1>
  <p>We extend the JS language with fixed-layout objects both for unshared and shared uses, unsafe blocks to syntactically limit the scope of where racy accesses may be performed, and high-level synchronization primitive APIs. This spec draft is organized by logical feature.</p>
</emu-intro>

<emu-clause id="sec-structs">
  <h1>Structs</h1>
  <p>Structs are fixed-layout objects. They are constructed with the integrity level ~sealed~, and have all declared fields initialized before the instance is made available to user code. They may only extend other structs. Their instance methods are non-generic, and throw *TypeError* exceptions when the *this* value is not either an instance of the struct declaration within which the method was declared, or a subclass of that struct declaration.</p>

  <emu-clause id="sec-structs-syntax-and-eval">
    <h1>Syntax</h1>

    <ins class="block">
    <emu-grammar type="definition">
      StructDeclaration[Yield, Await, Default] :
        `struct` [no LineTerminator here] BindingIdentifier[?Yield, ?Await] StructTail[?Yield, ?Await]
        [+Default] `struct` [no LineTerminator here] StructTail[?Yield, ?Await]

      StructExpression[Yield, Await] :
        `struct` [no LineTerminator here] BindingIdentifier[?Yield, ?Await]? StructTail[?Yield, ?Await]

      StructTail[Yield, Await] :
        ClassHeritage[?Yield, ?Await]? `{` StructBody[?Yield, ?Await]? `}`

      StructBody[Yield, Await] :
        ClassElementList[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>A struct definition is always strict mode code.</p>
    </emu-note>

    <emu-clause id="sec-struct-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>StructBody : ClassElementList</emu-grammar>
      <ul>
        <li>
          It is a SyntaxError if PrototypePropertyNameList of |ClassElementList| contains more than one occurrence of *"constructor"*.
        </li>
        <li>
          It is a Syntax Error if the PrivateBoundIdentifiers of |ClassElementList| contains any duplicate entries, unless the name is used once for a getter and once for a setter and in no other entries, and the getter and setter are either both static or both non-static.
        </li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-definestructfield" type="abstract operation">
      <h1>
        DefineStructField (
          _receiver_: an Object,
          _fieldRecord_: a ClassFieldDefinition Record,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _fieldName_ be _fieldRecord_.[[Name]].
        1. If _fieldName_ is a Private Name, then
          1. Perform ! PrivateFieldAdd(_receiver_, _fieldName_, *undefined*).
        1. Else,
          1. Assert: _fieldName_ is a property key.
          1. Perform ! DefinePropertyOrThrow(_receiver_, _fieldName_, PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-initializestructinstancefieldsandbrands" type="abstract operation">
      <h1>
        InitializeStructInstanceFieldsAndBrand (
          _receiver_: an Object,
          _constructor_: an ECMAScript function object,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _constructor_.[[ConstructorKind]] is ~derived~, then
          1. Let _parent_ be ! _constructor_.[[GetPrototypeOf]]().
          1. Perform InitializeStructInstanceFieldsAndBrand(_receiver_, _parent_).
        1. If _constructor_ has a [[StructBrand]] internal slot, then
          1. Prepend _constructor_.[[StructBrand]] to _receiver_.[[StructBrands]].
          1. NOTE: Shared Struct constructors do not have a [[StructBrand]] internal slot because per-Realm prototypes is currently an open design question and are not included in this draft. Without per-Realm prototypes, Shared Structs cannot have methods, and there are no users of Shared Struct brands.
        1. Let _methods_ be the value of _constructor_.[[PrivateMethods]].
        1. For each PrivateElement _method_ of _methods_, do
          1. Perform ! PrivateMethodOrAccessorAdd(_receiver_, _method_).
        1. Let _fields_ be the value of _constructor_.[[Fields]].
        1. For each element _fieldRecord_ of _fields_, do
          1. Perform DefineStructField(_receiver_, _fieldRecord_).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runfieldinitializer" type="abstract operation">
      <h1>
        RunFieldInitializer (
          _receiver_: an Object,
          _fieldRecord_: a ClassFieldDefinition Record,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _fieldName_ be _fieldRecord_.[[Name]].
        1. Let _initializer_ be _fieldRecord_.[[Initializer]].
        1. If _initializer_ is not ~empty~, then
          1. Let _initValue_ be ? Call(_initializer_, _receiver_).
          1. If _fieldName_ is a Private Name, then
            1. Perform ? PrivateSet(_receiver_, _fieldName_, _initValue_).
          1. Else,
            1. Assert: _fieldName_ is a property key.
            1. Perform ? DefinePropertyOrThrow(_receiver_, _fieldName_, PropertyDescriptor { [[Value]]: _initValue_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runstructinstancefieldinitializers" type="abstract operation">
      <h1>
        RunStructInstanceFieldInitializers (
          _receiver_: an Object,
          _constructor_: an ECMAScript function object,
        ): either a normal completion containing ~unused~ or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _constructor_.[[ConstructorKind]] is ~derived~, then
          1. Let _parent_ be ! _constructor_.[[GetPrototypeOf]]().
          1. Perform ? RunStructInstanceFieldInitializers(_receiver_, _parent_).
        1. Let _fields_ be the value of _constructor_.[[Fields]].
        1. For each element _fieldRecord_ of _fields_, do
          1. Perform ? RunFieldInitializer(_receiver_, _fieldRecord_).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-structdefinitionevaluation" type="sdo">
      <h1>
        Runtime Semantics: StructDefinitionEvaluation (
          _structBinding_: a String or *undefined*,
          _structName_: a property key,
        ): either a normal completion containing a function object or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>StructTail : ClassHeritage? `{` StructBody? `}`</emu-grammar>
      <emu-alg>
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _structEnv_ be NewDeclarativeEnvironment(_env_).
        1. If _structBinding_ is not *undefined*, then
          1. Perform ! _structEnv_.CreateImmutableBinding(_structBinding_, *true*).
        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.
        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).
        1. If |StructBody| is present, then
          1. For each String _dn_ of the PrivateBoundIdentifiers of |StructBody|, do
            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then
              1. Assert: This is only possible for getter/setter pairs.
            1. Else,
              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.
              1. Append _name_ to _classPrivateEnvironment_.[[Names]].
        1. If |ClassHeritage| is not present, then
          1. Let _protoParent_ be %Object.prototype%.
          1. Let _constructorParent_ be %Function.prototype%.
        1. Else,
          1. Set the running execution context's LexicalEnvironment to _structEnv_.
          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.
          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).
          1. Set the running execution context's LexicalEnvironment to _env_.
          1. Let _superclass_ be ? GetValue(? _superclassRef_).
          1. If _superclass_ is *null*, then
            1. Let _protoParent_ be *null*.
            1. Let _constructorParent_ be %Function.prototype%.
          1. Else if _superclass_ does not have a [[IsStructConstructor]] internal slot, then
            1. Throw a *TypeError* exception.
          1. Else,
            1. Let _protoParent_ be ? Get(_superclass_, *"prototype"*).
            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.
            1. Let _constructorParent_ be _superclass_.
        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_, « [[StructBrand]] »).
        1. Let _structSerial_ be the value of GlobalStructSerial.
        1. Set _proto_.[[StructBrand]] to _structSerial_.
        1. Set GlobalStructSerial to GlobalStructSerial + 1.
        1. NOTE: GlobalStructSerial is a monotonically increasing integer that is globally available. It is shared by all realms. Prior to the evaluation of any ECMAScript code, it is initialized to 0.
        1. NOTE: Structs have one-shot construction, with the user-defined "constructor" method performing post-construction initialization. By the time ECMAScript code has access to a struct instance, it already has all of its declared fields as own properties.
        1. Set the running execution context's LexicalEnvironment to _structEnv_.
        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.
        1. If |StructBody| is not present, let _initializerParseNode_ be ~empty~.
        1. Else, let _initializerParseNode_ be ConstructorMethod of |StructBody|.
        1. If _initializerParseNode_ is ~empty~, then
          1. Let _initializer_ be ~empty~.
        1. Else,
          1. Let _initializerInfo_ be ? DefineMethod of _initializerParseNode_ with arguments _proto_ and _constructorParent_.
          1. Let _initializer_ be _initializerInfo_.[[Closure]].
          1. Perform SetFunctionName(_initializer_, _structName_).
        1. Let _constructor_ be a new Abstract Closure with no parameters that captures _initializer_ and _structSerial_ and performs the following steps when called:
          1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].
          1. Let _F_ be the active function object.
          1. If NewTarget is not _F_, throw a *TypeError* exception.
          1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *"%Object.prototype%"*, « [[StructBrands]] »).
          1. Set _result_.[[StructBrands]] to « _structSerial_ ».
          1. Perform InitializeStructInstanceFieldsAndBrand(_result_, _F_).
          1. Perform ! _result_.[[PreventExtensions]]().
          1. Assert: ! TestIntegrityLevel(_result_, ~sealed~) is *true*.
          1. Perform ? RunStructInstanceFieldInitializers(_result_, _F_).
          1. If _initializer_ is not ~empty~, then
            1. Perform ? Call(_initializer_, _result_).
          1. Return _result_.
        1. Let _F_ be CreateBuiltinFunction(_constructor_, 0, structName, « [[ConstructorKind]], [[SourceText]], [[StructBrand]], [[StructInitializer]], [[IsStructConstructor]] », the current Realm Record, _constructorParent_).
        1. Perform MakeConstructor(_F_, *false*, _proto_).
        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.
        1. Set _F_.[[StructInitializer]] to _initializer_.
        1. Set _F_.[[StructBrand]] to _structSerial_.
        1. Set _F_.[[IsStructConstructor]] to *true*.
        1. If |StructBody| is not present, let _elements_ be a new empty List.
        1. Else, let _elements_ be NonConstructorElements of |StructBody|.
        1. Let _instancePrivateMethods_ be a new empty List.
        1. Let _staticPrivateMethods_ be a new empty List.
        1. Let _instanceFields_ be a new empty List.
        1. Let _staticElements_ be a new empty List.
        1. For each |ClassElement| _e_ of _elements_, do
          1. If IsStatic of _e_ is *false*, then
            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).
          1. Else,
            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).
          1. If _element_ is an abrupt completion, then
            1. Set the running execution context's LexicalEnvironment to _env_.
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return ? _element_.
          1. Set _element_ to ! _element_.
          1. If _element_ is a PrivateElement, then
            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.
            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.
            1. Else, let _container_ be _staticPrivateMethods_.
            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then
              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.
              1. If _element_.[[Get]] is *undefined*, then
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.
              1. Else,
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.
              1. Replace _pe_ in _container_ with _combined_.
            1. Else,
              1. Append _element_ to _container_.
          1. Else if _element_ is a ClassFieldDefinition Record, then
            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.
            1. Else, append _element_ to _staticElements_.
          1. Else if _element_ is a ClassStaticBlockDefinition Record, then
            1. Append _element_ to _staticElements_.
        1. Set the running execution context's LexicalEnvironment to _env_.
        1. If _structBinding_ is not *undefined*, then
          1. Perform ! _structEnv_.InitializeBinding(_structBinding_, _F_).
        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.
        1. Set _F_.[[Fields]] to _instanceFields_.
        1. For each PrivateElement _method_ of _staticPrivateMethods_, do
          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).
        1. For each element _elementRecord_ of _staticElements_, do
          1. If _elementRecord_ is a ClassFieldDefinition Record, then
            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).
          1. Else,
            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.
            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).
          1. If _result_ is an abrupt completion, then
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return ? _result_.
        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
        1. Perform ! SetIntegrityLevel(_proto_, ~sealed~).
        1. Return _F_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindingstructdeclarationevaluation" type="sdo">
      <h1>Runtime Semantics: BindingStructDeclarationEvaluation ( ): either a normal completion containing a function object or an abrupt completion</h1>
      <dl class="header">
      </dl>
      <emu-grammar>StructDeclaration : `struct` BindingIdentifier StructTail</emu-grammar>
      <emu-alg>
        1. Let _structName_ be the StringValue of |BindingIdentifier|.
        1. Let _value_ be ? StructDefinitionEvaluation of |StructTail| with arguments _structName_ and _structName_.
        1. Set _value_.[[SourceText]] to the source text matched by |StructDeclaration|.
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Perform ? InitializeBoundName(_structName_, _value_, _env_).
        1. Return _value_.
      </emu-alg>
      <emu-grammar>StructDeclaration : `struct` StructTail</emu-grammar>
      <emu-alg>
        1. Let _value_ be ? StructDefinitionEvaluation of |StructTail| with arguments *undefined* and *"default"*.
        1. Set _value_.[[SourceText]] to the source text matched by |StructDeclaration|.
        1. Return _value_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-struct-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>StructDeclaration : `struct` BindingIdentifier StructTail</emu-grammar>
      <emu-alg>
        1. Perform ? BindingStructDeclarationEvaluation of this |StructDeclaration|.
        1. Return ~empty~.
      </emu-alg>
      <emu-grammar>StructExpression : `struct` StructTail</emu-grammar>
      <emu-alg>
        1. Let _value_ be ? StructDefinitionEvaluation of |StructTail| with arguments *undefined* and *""*.
        1. Set _value_.[[SourceText]] to the source text matched by |StructExpression|.
        1. Return _value_.
      </emu-alg>
      <emu-grammar>StructExpression : `struct` BindingIdentifier StructTail</emu-grammar>
      <emu-alg>
        1. Let _structName_ be StringValue of |BindingIdentifier|.
        1. Let _value_ be ? StructDefinitionEvaluation of |StructTail| with arguments _structName_ and _structName_.
        1. Set _value_.[[SourceText]] to the source text matched by |StructExpression|.
        1. Return _value_.
      </emu-alg>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-struct-method-exotic-objects">
    <h1>Struct Method Exotic Objects</h1>
    <ins class="block">

    <p>A struct method exotic object is an exotic object that wraps another method. A struct method exotic object is callable (it has a [[Call]] internal method). Calling a struct method exotic object checks if the *this* value is a struct instance constructed by the same struct declaration that defined the method, then in calls its wrapped method.</p>

    <p>An object is a <dfn id="struct-method-exotic-object" variants="struct method exotic objects">struct method exotic object</dfn> if its [[Call]] internal method uses the following implementation, and its other essential internal methods use the definitions found in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>. These methods are installed in StructMethodCreate.</p>

    <p>Struct method exotic objects do not have the internal slots of ECMAScript function objects listed in <emu-xref href="#table-internal-slots-of-ecmascript-function-objects"></emu-xref>. Instead they have the internal slots listed in <emu-xref href="#table-internal-slots-of-struct-method-exotic-objects"></emu-xref>, in addition to [[Prototype]] and [[Extensible]].</p>
    <emu-table id="table-internal-slots-of-struct-method-exotic-objects" caption="Internal Slots of Struct Method Exotic Objects">
      <table>
        <thead>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Type
            </th>
            <th>
              Description
            </th>
          </tr>
        </thead>
        <tr>
          <td>
            [[BoundTargetMethod]]
          </td>
          <td>
            a callable Object
          </td>
          <td>
            The wrapped method object.
          </td>
        </tr>
      </table>
    </emu-table>

    <emu-clause id="sec-struct-method-exotic-objects-call-thisargument-argumentslist" type="internal method">
      <h1>
        [[Call]] (
          _thisArgument_: an ECMAScript language value,
          _argumentsList_: a List of ECMAScript language values,
        ): either a normal completion containing an ECMAScript language value or a throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a struct method exotic object _F_</dd>
      </dl>
      <emu-alg>
        1. Let _target_ be _F_.[[BoundTargetMethod]].
        1. Let _homeObject_ be _target_.[[HomeObject]].
        1. Assert: _homeObject_ is not *undefined*.
        1. Assert: _homeObject_ has a [[StructBrand]] internal slot.
        1. If _thisArgument_ is not an Object, throw a *TypeError* exception.
        1. If _thisArgument_ does not have a [[StructBrands]] internal slot, throw a *TypeError* exception.
        1. If _thisArgument_.[[StructBrands]] does not contain _homeObject_.[[StructBrand]], throw a *TypeError* exception.
        1. Return ? Call(_target_, _thisArgument_, argumentsList_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-structmethodcreate" type="abstract operation">
      <h1>
        StructMethodCreate (
          _targetMethod_: a function object,
        ): either a normal completion containing a function object or a throw completion
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It is used to specify the creation of new struct method exotic objects.</dd>
      </dl>
      <emu-alg>
        1. Let _proto_ be ? <emu-meta effects="user-code">_targetMethod_.[[GetPrototypeOf]]</emu-meta>().
        1. Let _internalSlotsList_ be the list-concatenation of « [[Prototype]], [[Extensible]] » and the internal slots listed in <emu-xref href="#table-internal-slots-of-struct-method-exotic-objects"></emu-xref>.
        1. Let _obj_ be MakeBasicObject(_internalSlotsList_).
        1. Set _obj_.[[Prototype]] to _proto_.
        1. Set _obj_.[[Call]] as described in <emu-xref href="#sec-struct-method-exotic-objects-call-thisargument-argumentslist"></emu-xref>.
        1. Set _obj_.[[BoundTargetMethod]] to _targetMethod_.
        1. Return _obj_.
      </emu-alg>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="changes-to-language-expressions">
    <h1>Changes to ECMAScript Language: Expressions</h1>
    <emu-clause id="sec-super-keyword-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>SuperCall : `super` Arguments</emu-grammar>
        <emu-alg>
          1. Let _newTarget_ be GetNewTarget().
          1. Assert: _newTarget_ is an Object.
          1. Let _func_ be GetSuperConstructor().
          1. Let _argList_ be ? ArgumentListEvaluation of |Arguments|.
          1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.
          1. <ins>If _func_ has a [[StructInitializer]] internal slot, then</ins>
            1. <ins>If _func_.[[StructInitializer]] is not ~empty~, then</ins>
              1. <ins>Let _envRec_ be GetThisEnvironment().</ins>
              1. <ins>Let _thisValue_ be _envRec_.GetThisBinding().</ins>
              1. <ins>Return ? Call(_func_.[[StructInitializer]], _thisValue_).</ins>
            1. <ins>Else,</ins>
              1. <ins>Return *undefined*.</ins>
          1. Let _result_ be ? Construct(_func_, _argList_, _newTarget_).
          1. Let _thisER_ be GetThisEnvironment().
          1. Perform ? _thisER_.BindThisValue(_result_).
          1. Let _F_ be _thisER_.[[FunctionObject]].
          1. Assert: _F_ is an ECMAScript function object.
          1. Perform ? InitializeInstanceElements(_result_, _F_).
          1. Return _result_.
        </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="changes-to-language-functions-and-classes">
    <h1>Changes to ECMAScript Language: Functions and Classes</h1>
    <emu-clause id="sec-runtime-semantics-definemethod" type="sdo">
      <h1>
        Runtime Semantics: DefineMethod (
          _object_: an Object,
          optional _functionPrototype_: an Object,
        ): either a normal completion containing a Record with fields [[Key]] (a property key) and [[Closure]] (an ECMAScript function object) or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>MethodDefinition : ClassElementName `(` UniqueFormalParameters `)` `{` FunctionBody `}`</emu-grammar>
      <emu-alg>
        1. Let _propKey_ be ? Evaluation of |ClassElementName|.
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.
        1. If _functionPrototype_ is present, then
          1. Let _prototype_ be _functionPrototype_.
        1. Else,
          1. Let _prototype_ be %Function.prototype%.
        1. Let _sourceText_ be the source text matched by |MethodDefinition|.
        1. Let _closure_ be OrdinaryFunctionCreate(_prototype_, _sourceText_, |UniqueFormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).
        1. Perform MakeMethod(_closure_, _object_).
        1. <ins>If _object_ has a [[StructBrand]] internal slot, then</ins>
          1. <ins>NOTE: Struct instance methods' home object have a [[StructBrand]] internal slot.</ins>
          1. <ins>Set _closure_ to ? StructMethodCreate(_closure_).</ins>
        1. Return the Record { [[Key]]: _propKey_, [[Closure]]: _closure_ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-changes-to-modules">
    <h1>Changes to Modules</h1>

    <emu-grammar type="definition">
      ExportDeclaration :
        `export` ExportFromClause FromClause `;`
        `export` NamedExports `;`
        `export` VariableStatement[~Yield, +Await]
        `export` Declaration[~Yield, +Await]
        `export` `default` HoistableDeclaration[~Yield, +Await, +Default]
        `export` `default` ClassDeclaration[~Yield, +Await, +Default]
        <ins>`export` `default` StructDeclaration[~Yield, +Await, +Default]</ins>
        `export` `default` [lookahead &notin; { `function`, `async` [no LineTerminator here] `function`, `class` }] AssignmentExpression[+In, ~Yield, +Await] `;`
    </emu-grammar>

    <emu-clause id="sec-exports-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <ins class="block">
      <emu-grammar>ExportDeclaration : `export` `default` StructDeclaration</emu-grammar>
      <emu-alg>
        1. Let _value_ be ? BindingStructDeclarationEvaluation of |StructDeclaration|.
        1. Let _structName_ be the sole element of the BoundNames of |StructDeclaration|.
        1. If _structName_ is *"\*default\*"*, then
          1. Let _env_ be the running execution context's LexicalEnvironment.
          1. Perform ? InitializeBoundName(*"\*default\*"*, _value_, _env_).
        1. Return ~empty~.
      </emu-alg>
      </ins>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-shared-structs">
  <h1>Shared Structs</h1>

  <emu-clause id="sec-shared-struct-exotic-objects">
    <h1>Shared Struct Exotic Objects</h1>
    <ins class="block">
    <p>Shared Structs are fixed-layout exotic objects that can be shared across agents and be accessed in parallel from multiple agents. They are like structs with more restricted behaviour so as to be possible to be shared across agents. They cannot contain methods or private fields. Their fields can only hold primitives or other shared values. Accessing their fields is unordered by default and is governed by the memory model. Such accesses can be made sequentially consistent by using newly overloaded Atomics methods.</p>
    <p>An object is a <dfn id="shared-struct-exotic-object" variants="Shared Structs">Shared Struct</dfn> if its [[GetOwnProperty]], [[DefineOwnProperty]], [[HasProperty]], [[Get]], [[Set]], and [[Delete]] internal methods use the definitions in this section, and its other essential internal methods use the definitions found in <emu-xref href="#sec-ordinary-object-internal-methods-and-internal-slots"></emu-xref>.</p>

    <emu-clause id="sec-fictional-criticalsection">
      <h1>Critical Section for Shared Struct Creation</h1>

      <emu-clause id="sec-entersharedstructcreationcriticalsection" type="abstract operation">
        <h1>
          EnterSharedStructCreationCriticalSection (
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is not in the critical section for Shared Struct creation.
          1. Wait until no agent is in the critical section for Shared Struct creation, then enter the critical section for Shared Struct creation (without allowing any other agent to enter).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-leavesharedstructcreationcriticalsection" type="abstract operation">
        <h1>
          LeaveSharedStructCreationCriticalSection (
          ): ~unused~
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Assert: The surrounding agent is in the critical section for Shared Struct creation.
          1. Leave the critical section for Shared Struct creation.
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-note>
        <p>This critical section is a specification semantic prescription of the memory model to prohibit the nondeterministic read in ReadSharedStructField from manifesting Shared Struct values that are partially initialized.</p>
        <p>This critical section does not provide any ordering guarantees.</p>
        <p>In implementations, this critical section is not needed. Implementations must not allow out-of-thin-air reads.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-sharedstructcreate" type="abstract operation">
      <h1>
        SharedStructCreate (
          _initializer_: an Abstract Closure with one parameter,
          optional _internalSlotsList_: a List of internal slot names,
        ) : a Shared Struct
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _internalSlotsList_ is not present, set _internalSlotsList_ to a new empty List.
        1. Perform EnterSharedStructCreationCriticalSection().
        1. Let _result_ be OrdinaryObjectCreate(*null*, _internalSlotsList_).
        1. Set _result_.[[GetOwnProperty]] as specified in <emu-xref href="#sec-shared-struct-getownproperty"></emu-xref>.
        1. Set _result_.[[DefineOwnProperty]] as specified in <emu-xref href="#sec-shared-struct-defineownproperty"></emu-xref>.
        1. Set _result_.[[HasProperty]] as specified in <emu-xref href="#sec-shared-struct-hasproperty"></emu-xref>.
        1. Set _result_.[[Get]] as specified in <emu-xref href="#sec-shared-struct-get"></emu-xref>.
        1. Set _result_.[[Set]] as specified in <emu-xref href="#sec-shared-struct-set"></emu-xref>.
        1. Set _result_.[[UnsafeGet]] as specified in <emu-xref href="#sec-shared-struct-unsafeget"></emu-xref>.
        1. Set _result_.[[UnsafeSet]] as specified in <emu-xref href="#sec-shared-struct-unsafeset"></emu-xref>.
        1. Set _result_.[[Delete]] as specified in <emu-xref href="#sec-shared-struct-delete"></emu-xref>.
        1. Perform _initializer_(_result_).
        1. Perform ! _result_.[[PreventExtensions]]().
        1. Perform LeaveSharedStructCreationCriticalSection().
        1. Assert: ! TestIntegrityLevel(_result_, ~sealed~) is *true*.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-readsharedstructfield" type="abstract operation">
      <h1>
        ReadSharedStructField (
          _struct_: a Shared Struct,
          _field_: a property key,
          _order_: ~seq-cst~ or ~unordered~,
        ): an ECMAScript language value
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
        1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
        1. Let _storage_ be SharedStructStorage { [[Struct]]: _struct_, [[Field]]: _field_ }.
        1. Perform EnterSharedStructCreationCriticalSection().
        1. Let _rawLanguageValue_ be a nondeterministically chosen ECMAScript language value such that CanBeSharedAcrossAgents(_rawLanguageValue_) is *true*.
        1. Perform LeaveSharedStructCreationCriticalSection().
        1. NOTE: In implementations, _rawLanguageValue_ is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
        1. Let _readEvent_ be ReadSharedMemory { [[Order]]: _order_, [[NoTear]]: *true*, [[Storage]]: _storage_ } to _eventsRecord_.[[EventList]].
        1. Append _readEvent_ to _eventsRecord_.[[EventList]].
        1. NOTE: Shared struct field accesses can never tear.
        1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawLanguageValue_ } to _execution_.[[ChosenValues]].
        1. Return _rawLanguageValue_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-writesharedstructfield" type="abstract operation">
      <h1>
        WriteSharedStructField (
          _struct_: a Shared Struct,
          _field_: a property key,
          _value_: an ECMAScript language value,
          _order_: ~seq-cst~, ~unordered~, or ~init~,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: CanBeSharedAcrossAgents(_value_) is *true*.
        1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
        1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
        1. Let _storage_ be SharedStructStorage { [[Struct]]: _struct_, [[Field]]: _field_ }.
        1. Append WriteSharedMemory { [[Order]]: _order_, [[NoTear]]: *true*, [[Storage]]: _storage_, [[Payload]]: _value_ } to _eventsRecord_.[[EventList]].
        1. NOTE: Shared struct field accesses can never tear.
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-shared-struct-getownproperty" type="internal method">
      <h1>
        [[GetOwnProperty]] (
          _P_: a property key,
        ): a normal completion containing either a Property Descriptor or *undefined*
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Shared Struct _O_</dd>
      </dl>
      <emu-alg>
        1. If _O_ does not have an own property with key _P_, return *undefined*.
        1. Let _D_ be a newly created Property Descriptor with no fields.
        1. Let _X_ be _O_'s own property whose key is _P_.
        1. Assert: _X_ is a data property.
        1. Set _D_.[[Value]] to ReadSharedStructField(_O_, _P_, ~unordered~).
        1. Set _D_.[[Writable]] to *false*.
        1. Set _D_.[[Enumerable]] to *true*.
        1. Set _D_.[[Configurable]] to *false*.
        1. Return _D_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-shared-struct-defineownproperty" type="internal method">
      <h1>
        [[DefineOwnProperty]] (
          _P_: a property key,
          _Desc_: a Property Descriptor,
        ): either a normal completion containing a Boolean or a throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Shared Struct _O_</dd>
      </dl>
      <emu-alg>
        1. Assert: ! TestIntegrityLevel(_O_, ~sealed~) is *true*.
        1. Let _current_ be ! _O_.[[GetOwnProperty]](_P_).
        1. If _current_ is *undefined*, return *false*.
        1. Assert: IsDataDescriptor(_current_) is *true*.
        1. Assert: _current_.[[Enumerable]] is *true*.
        1. Assert: _current_.[[Configurable]] is *false*.
        1. Assert: _current_.[[Writable]] is *true*.
        1. If _Desc_ has a [[Enumerable]] field and _Desc_.[[Enumerable]] is *false*, return *false*.
        1. If _Desc_ has a [[Configurable]] field and _Desc_.[[Configurable]] is *true*, return *false*.
        1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *false*, return *false*.
        1. If _Desc_ has a [[Value]] field, then
          1. If CanBeSharedAcrossAgents(_Desc_.[[Value]]) is *false*, throw a *TypeError* exception.
          1. Perform WriteSharedStructField(_O_, _P_, _Desc_.[[Value]], ~unordered~).
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-shared-struct-hasproperty" type="internal method">
      <h1>
        [[HasProperty]] (
          _P_: a property key,
        ): a normal completion containing a Boolean
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Shared Struct _O_</dd>
      </dl>
      <emu-alg>
        1. If _O_ does not have an own property with key _P_, return *false*.
        1. NOTE: [[GetOwnPropertyDescriptor]] is not used to avoid an unnecessary ReadSharedMemory event.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-shared-struct-get" type="internal method">
      <h1>
        [[Get]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): either a normal completion containing *undefined* or a throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a shared Struct _O_</dd>
      </dl>
      <emu-alg>
        1. Let _ownDesc_ be ! _O_.[[GetOwnProperty]](_P_).
        1. If _ownDesc_ is *undefined*, return *undefined*.
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-shared-struct-set" type="internal method">
      <h1>
        [[Set]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or a throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Shared Struct _O_</dd>
      </dl>
      <emu-alg>
        1. If _O_ does not have an own property with key _P_, return *false*.
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-shared-struct-unsafeget" type="internal method">
      <h1>
        [[UnsafeGet]] (
          _P_: a property key,
          _Receiver_: an ECMAScript language value,
        ): a normal completion containing an ECMAScript language value
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a shared Struct _O_</dd>
      </dl>
      <emu-alg>
        1. Let _ownDesc_ be ! _O_.[[GetOwnProperty]](_P_).
        1. If _ownDesc_ is *undefined*, return *undefined*.
        1. Return _ownDesc_.[[Value]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-shared-struct-unsafeset" type="internal method">
      <h1>
        [[UnsafeSet]] (
          _P_: a property key,
          _V_: an ECMAScript language value,
          _Receiver_: an ECMAScript language value,
        ): either a normal completion containing a Boolean or a throw completion
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Shared Struct _O_</dd>
      </dl>
      <emu-alg>
        1. If _O_ does not have an own property with key _P_, return *false*.
        1. NOTE: [[GetOwnPropertyDescriptor]] is not used to avoid an unnecessary ReadSharedMemory event.
        1. Let _desc_ be PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }.
        1. Return ? _O_.[[DefineOwnProperty]](_P_, _desc_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-shared-struct-delete" type="internal method">
      <h1>
        [[Delete]] (
          _P_: a property key,
        ): a normal completion containing *false*
      </h1>
      <dl class="header">
        <dt>for</dt>
        <dd>a Shared Struct _O_</dd>
      </dl>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-shared-structs-syntax-and-eval">
    <h1>Syntax</h1>

    <ins class="block">
    <emu-grammar type="definition">
      StructDeclaration[Yield, Await, Default] :
        `shared` [no LineTerminator here] `struct` [no LineTerminator here] BindingIdentifier[?Yield, ?Await] SharedStructTail[?Yield, ?Await]
        [+Default] `shared` [no LineTerminator here] `struct` [no LineTerminator here] SharedStructTail[?Yield, ?Await]

      StructExpression[Yield, Await] :
        `shared` [no LineTerminator here] `struct` [no LineTerminator here] BindingIdentifier[?Yield, ?Await]? SharedStructTail[?Yield, ?Await]

      SharedStructTail[Yield, Await] :
        ClassHeritage[?Yield, ?Await]? `{` SharedStructBody[?Yield, ?Await]? `}`

      SharedStructBody[Yield, Await] :
        ClassElementList[?Yield, ?Await]
    </emu-grammar>
    <emu-note>
      <p>A shared struct definition is always strict mode code.</p>
    </emu-note>

    <emu-clause id="sec-struct-definitions-static-semantics-containsinstanceprivateidentifier" type="sdo">
      <h1>Static Semantics: ContainsInstancePrivateIdentifier ( ) : a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. Return ContainsInstancePrivateIdentifier of |ClassElement|.
      </emu-alg>

      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. If ContainsInstancePrivateIdentifier of |ClassElementList|, return *true*.
        1. Return ContainsInstancePrivateIdentifier of |ClassElement|.
      </emu-alg>

      <emu-grammar>ClassElement : FieldDefinition `;`</emu-grammar>
      <emu-alg>
        1. Return |FieldDefinition| Contains |PrivateIdentifier|.
      </emu-alg>

      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. Return |MethodDefinition| Contains |PrivateIdentifier|.
      </emu-alg>

      <emu-grammar>
        ClassElement :
          `static` FieldDefinition `;`
          `static` MethodDefinition
          ClassStaticBlock
          `;`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-struct-definitions-static-semantics-containsinstancemethod" type="sdo">
      <h1>Static Semantics: ContainsInstanceMethod ( ) : a Boolean</h1>
      <dl class="header">
      </dl>
      <emu-grammar>ClassElementList : ClassElement</emu-grammar>
      <emu-alg>
        1. Return ContainsInstanceMethod of |ClassElement|.
      </emu-alg>

      <emu-grammar>ClassElementList : ClassElementList ClassElement</emu-grammar>
      <emu-alg>
        1. If ContainsInstanceMethod of |ClassElementList|, return *true*.
        1. Return ContainsInstanceMethod of |ClassElement|.
      </emu-alg>

      <emu-grammar>ClassElement : MethodDefinition</emu-grammar>
      <emu-alg>
        1. If ClassElementKind of |ClassElement| is ~constructor-method~, return *false*.
        1. Return *true*.
      </emu-alg>

      <emu-grammar>
        ClassElement :
          FieldDefinition `;`
          `static` FieldDefinition `;`
          `static` MethodDefinition
          ClassStaticBlock
          `;`
      </emu-grammar>
      <emu-alg>
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-shared-struct-definitions-static-semantics-early-errors">
      <h1>Static Semantics: Early Errors</h1>
      <emu-grammar>SharedStructBody : ClassElementList</emu-grammar>
      <ul>
        <li>
          It is a SyntaxError if PrototypePropertyNameList of |ClassElementList| contains more than one occurrence of *"constructor"*.
        </li>
        <li>
          It is a Syntax Error if ContainsInstancePrivateIdentifier of |ClassElementList| is *true*.
        </li>
        <li>
          It is a SyntaxError if ContainsInstanceMethod of |ClassElementList| is *true*.
        </li>
      </ul>
      <emu-note>
        <p>EDITOR'S NOTE: Per-Realm prototypes, which is currently an open design question and not included in this draft, will allow methods.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-canbesharedacrossagents" type="abstract operation">
      <h1>
        CanBeSharedAcrossAgents (
          _val_: an ECMAScript language value
        ): a Boolean
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>
          <p>Returns whether ECMAScript language language values can be shared across agents. Primitives can always be shared.</p>
        </dd>
      </dl>
      <emu-alg>
        1. If _val_ is *undefined*, return *true*.
        1. If _val_ is *null*, return *true*.
        1. If _val_ is a String, return *true*.
        1. If _val_ is a Boolean, return *true*.
        1. If _val_ is a Number, return *true*.
        1. If _val_ is a BigInt, return *true*.
        1. If _val_ is a Symbol, return *true*.
        1. Assert: _val_ is an Object.
        1. If _val_ is a Shared Struct exotic object, return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-definesharedstructfield" type="abstract operation">
      <h1>
        DefineSharedStructField (
          _receiver_: a Shared Struct,
          _fieldRecord_: a ClassFieldDefinition Record,
        ): ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: The surrounding agent is in the critical section for Shared Struct creation.
        1. Let _fieldName_ be _fieldRecord_.[[Name]].
        1. Assert: _fieldName_ is a property key.
        1. Create an own data property named _fieldName_ of object _receiver_ whose [[Value]] is *undefined*, [[Writable]] is *true*, [[Enumerable]] is *true*, and [[Configurable]] is *false*.
        1. Perform WriteSharedStructField(_receiver_, _fieldName_, *undefined*, ~init~).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-sharedstructdefinitionevaluation" type="sdo">
      <h1>
        Runtime Semantics: SharedStructDefinitionEvaluation (
          _structBinding_: a String or *undefined*,
          _structName_: a property key,
        ): either a normal completion containing a function object or an abrupt completion
      </h1>
      <dl class="header">
      </dl>
      <emu-grammar>SharedStructTail : ClassHeritage? `{` SharedStructBody? `}`</emu-grammar>
      <emu-alg>
        1. Let _env_ be the LexicalEnvironment of the running execution context.
        1. Let _structEnv_ be NewDeclarativeEnvironment(_env_).
        1. If _structBinding_ is not *undefined*, then
          1. Perform ! _structEnv_.CreateImmutableBinding(_structBinding_, *true*).
        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.
        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).
        1. If |SharedStructBody| is present, then
          1. For each String _dn_ of the PrivateBoundIdentifiers of |SharedStructBody|, do
            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then
              1. Assert: This is only possible for getter/setter pairs.
            1. Else,
              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.
              1. Append _name_ to _classPrivateEnvironment_.[[Names]].
        1. If |ClassHeritage| is not present, then
          1. Let _constructorParent_ be %Function.prototype%.
        1. Else,
          1. Set the running execution context's LexicalEnvironment to _structEnv_.
          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).
          1. Set the running execution context's LexicalEnvironment to _env_.
          1. Let _superclass_ be ? GetValue(? _superclassRef_).
          1. If _superclass_ is *null*, then
            1. Let _constructorParent_ be %Function.prototype%.
          1. Else if _superclass_ does not have a [[IsSharedStructConstructor]] internal slot, then
            1. Throw a *TypeError* exception.
          1. Else,
            1. Let _constructorParent_ be _superclass_.
        1. Let _proto_ be *null*.
        1. NOTE: Per-Realm prototypes, which is currently an open design question and not included in this draft, will allow prototypes.
        1. NOTE: Shared Structs have one-shot construction, with the user-defined "constructor" method performing post-construction initialization. By the time ECMAScript code has access to a Shared Struct instance, it already has all of its declared fields as own properties.
        1. Set the running execution context's LexicalEnvironment to _structEnv_.
        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.
        1. If |SharedStructBody| is not present, let _initializerParseNode_ be ~empty~.
        1. Else, let _initializerParseNode_ be ConstructorMethod of |SharedStructBody|.
        1. If _initializerParseNode_ is ~empty~, then
          1. Let _initializer_ be ~empty~.
        1. Else,
          1. Let _initializerInfo_ be ? DefineMethod of _initializerParseNode_ with arguments _proto_ and _constructorParent_.
          1. Let _initializer_ be _initializerInfo_.[[Closure]].
          1. Perform SetFunctionName(_initializer_, _structName_).
        1. Let _constructor_ be a new Abstract Closure with no parameters that captures _initializer_ and performs the following steps when called:
          1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].
          1. Let _F_ be the active function object.
          1. If NewTarget is not _F_, throw a *TypeError* exception.
          1. Let _createInitializer_ be a new Abstract Closure with parameters (_newSharedStruct_) that captures _F_ and performs the following steps when called:
            1. Perform InitializeStructInstanceFieldsAndBrand(_newSharedStruct_, _F_).
            1. Return ~unused~.
          1. Let _result_ be SharedStructCreate(_createInitializer_).
          1. Perform ? RunStructInstanceFieldInitializers(_result_, _F_).
          1. If _initializer_ is not ~empty~, then
            1. Perform ? Call(_initializer_, _result_).
          1. Return _result_.
        1. Let _F_ be CreateBuiltinFunction(_constructor_, 0, structName, « [[ConstructorKind]], [[SourceText]], [[StructInitializer]], [[IsSharedStructConstructor]] », the current Realm Record, _constructorParent_).
        1. Perform MakeConstructor(_F_, *false*, _proto_).
        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.
        1. Set _F_.[[StructInitializer]] to _initializer_.
        1. Set _F_.[[IsSharedStructConstructor]] to *true*.
        1. If |StructBody| is not present, let _elements_ be a new empty List.
        1. Else, let _elements_ be NonConstructorElements of |SharedStructBody|.
        1. Let _staticPrivateMethods_ be a new empty List.
        1. Let _instanceFields_ be a new empty List.
        1. Let _staticElements_ be a new empty List.
        1. For each |ClassElement| _e_ of _elements_, do
          1. If IsStatic of _e_ is *false*, then
            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).
          1. Else,
            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).
          1. If _element_ is an abrupt completion, then
            1. Set the running execution context's LexicalEnvironment to _env_.
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return ? _element_.
          1. Set _element_ to ! _element_.
          1. If _element_ is a PrivateElement, then
            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.
            1. Assert: IsStatic of _e_ is *true*.
            1. Let _container_ be _staticPrivateMethods_.
            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then
              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.
              1. If _element_.[[Get]] is *undefined*, then
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.
              1. Else,
                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.
              1. Replace _pe_ in _container_ with _combined_.
            1. Else,
              1. Append _element_ to _container_.
          1. Else if _element_ is a ClassFieldDefinition Record, then
            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.
            1. Else, append _element_ to _staticElements_.
          1. Else if _element_ is a ClassStaticBlockDefinition Record, then
            1. Append _element_ to _staticElements_.
        1. Set the running execution context's LexicalEnvironment to _env_.
        1. If _structBinding_ is not *undefined*, then
          1. Perform ! _structEnv_.InitializeBinding(_structBinding_, _F_).
        1. Set _F_.[[Fields]] to _instanceFields_.
        1. For each PrivateElement _method_ of _staticPrivateMethods_, do
          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).
        1. For each element _elementRecord_ of _staticElements_, do
          1. If _elementRecord_ is a ClassFieldDefinition Record, then
            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).
          1. Else,
            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.
            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).
          1. If _result_ is an abrupt completion, then
            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
            1. Return ? _result_.
        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.
        1. Perform ! SetIntegrityLevel(_F_, ~sealed~).
        1. Return _F_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-runtime-semantics-bindingsharedstructdeclarationevaluation" type=""sdo">
      <h1>Runtime Semantics: BindingStructDeclarationEvaluation</h1>
      <emu-grammar>StructDeclaration : `shared` `struct` BindingIdentifier SharedStructTail</emu-grammar>
      <emu-alg>
        1. Let _structName_ be the StringValue of |BindingIdentifier|.
        1. Let _value_ be ? SharedStructDefinitionEvaluation of |StructTail| with arguments _structName_ and _structName_.
        1. Set _value_.[[SourceText]] to the source text matched by |StructDeclaration|.
        1. Let _env_ be the running execution context's LexicalEnvironment.
        1. Perform ? InitializeBoundName(_structName_, _value_, _env_).
        1. Return _value_.
      </emu-alg>
      <emu-grammar>StructDeclaration : `shared` `struct` SharedStructTail</emu-grammar>
      <emu-alg>
        1. Let _value_ be ? SharedStructDefinitionEvaluation of |SharedStructTail| with arguments *undefined* and *"default"*.
        1. Set _value_.[[SourceText]] to the source text matched by |StructDeclaration|.
        1. Return _value_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-shared-struct-definitions-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>
      <emu-grammar>StructDeclaration : `shared` `struct` BindingIdentifier SharedStructTail</emu-grammar>
      <emu-alg>
        1. Perform ? BindingStructDeclarationEvaluation of this |StructDeclaration|.
        1. Return ~empty~.
      </emu-alg>
      <emu-grammar>StructExpression : `shared` `struct` SharedStructTail</emu-grammar>
      <emu-alg>
        1. Let _value_ be ? SharedStructDefinitionEvaluation of |SharedStructTail| with arguments *undefined* and *""*.
        1. Set _value_.[[SourceText]] to the source text matched by |StructExpression|.
        1. Return _value_.
      </emu-alg>
      <emu-grammar>StructExpression : `shared` `struct` BindingIdentifier SharedStructTail</emu-grammar>
      <emu-alg>
        1. Let _structName_ be StringValue of |BindingIdentifier|.
        1. Let _value_ be ? SharedStructDefinitionEvaluation of |SharedStructTail| with arguments _structName_ and _structName_.
        1. Set _value_.[[SourceText]] to the source text matched by |StructExpression|.
        1. Return _value_.
      </emu-alg>
    </emu-clause>
    </ins>
  </emu-clause>

  <emu-clause id="sec-changes-to-atomics-object">
    <h1>Changes to the Atomics Object</h1>

    <ins class="block">
    <emu-clause id="sec-atomiccompareexchangeinsharedstruct" type="abstract operation">
      <h1>
        AtomicCompareExchangeInSharedStruct (
          _struct_: a Shared Struct,
          _field_: a property key,
          _expectedValue_: an ECMAScript language value,
          _replacementValue_: an ECMAScript language value
        ): an ECMAScript language value
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: CanBeSharedAcrossAgents(_replacementValue_) is *true*.
        1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
        1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
        1. Perform EnterSharedStructCreationCriticalSection().
        1. Let _rawLanguageValue_ be a nondeterministically chosen ECMAScript language value such that CanBeSharedAcrossAgents(_rawLanguageValue_) is *true*.
        1. Perform LeaveSharedStructCreationCriticalSection().
        1. NOTE: In implementations, _rawLanguageValue_ is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
        1. NOTE: The comparison of the expected value and the read value is performed outside of the read-modify-write modification function to avoid needlessly strong synchronization when the expected value is not equal to the read value.
        1. Let _storage_ be SharedStructStorage { [[Struct]]: _struct_, [[Field]]: _field_ }.
        1. If SameValue(_expectedValue_, _replacementValue_) is *true*, then
          1. Let _second_ be a new read-modify-write modification function with parameters (_oldValue_, _newValue_) that captures nothing and performs the following steps atomically when called:
            1. Return _newValue_.
          1. Let _event_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Storage]]: _storage_, [[Payload]]: _replacementValue_, [[ModifyOp]]: _second_ }.
        1. Else,
          1. Let _event_ be ReadSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Storage]]: _storage_ }.
        1. Append _event_ to _eventsRecord_.[[EventList]].
        1. Append Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawLanguageValue_ } to _execution_.[[ChosenValues]].
        1. Return _rawLanguageValue_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomicreadmodifywriteinsharedstruct" type="abstract operation">
      <h1>
        AtomicReadModifyWriteInSharedStruct (
          _struct_: a Shared Struct
          _field_: an ECMAScript language value,
          _value_: an ECMAScript language value,
          _op_: a read-modify-write modification function,
        ): either a normal completion containing an ECMAScript language value, or a throw completion
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. If _field_ is not a property key, throw a *TypeError* exception.
        1. If CanBeSharedAcrossAgents(_value_) is *false*, throw a *TypeError* exception.
        1. If _struct_ does not have an own property with key _field_, throw a *RangeError* exception.
        1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
        1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
        1. Perform EnterSharedStructCreationCriticalSection().
        1. Let _rawLanguageValue_ be a nondeterministically chosen ECMAScript language value such that CanBeSharedAcrossAgents(_rawLanguageValue_) is *true*.
        1. Perform LeaveSharedStructCreationCriticalSection().
        1. NOTE: In implementations, _rawLanguageValue_ is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.
        1. Let _storage_ be SharedStructStorage { [[Struct]]: _struct_, [[Field]]: _field_ }.
        1. Let _rmwEvent_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Storage]]: _storage_, [[Payload]]: _rawLanguageValue_, [[ModifyOp]]: _op_ }.
        1. Append _rmwEvent_ to _eventsRecord_.[[EventList]].
        1. Append Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawLanguageValue_ } to _execution_.[[ChosenValues]].
        1. Return _rawLanguageValue_.
      </emu-alg>
    </emu-clause>
    </ins>

    <emu-clause id="sec-atomics.compareexchange-struct">
      <h1>Atomics.compareExchange ( <del>_typedArray_</del><ins>_typedArrayOrStruct_</ins>, <del>_index_</del><ins>_indexOrField_</ins>, _expectedValue_, _replacementValue_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. <ins>If _typedArrayOrStruct_ is a Shared Struct, then</ins>
          1. <ins>If _indexOrField_ is not a property key, throw a *TypeError* exception.</ins>
          1. <ins>If CanBeSharedAcrossAgents(_replacementValue_) is *false*, throw a *TypeError* exception.</ins>
          1. <ins>If _typedArrayOrStruct_ does not have an own property with key _indexOrField_, throw a *RangeError* exception.</ins>
          1. <ins>Return AtomicCompareExchangeInSharedStruct(_typedArrayOrStruct_, _indexOrField_, _expectedValue_, _replacementValue_).</ins>
        1. <ins>Let _typedArray_ be _typedArrayOrStruct_.</ins>
        1. <ins>Let _index_ be _indexOrField_.</ins>
        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. Let _block_ be _buffer_.[[ArrayBufferData]].
        1. If _typedArray_.[[ContentType]] is ~bigint~, then
          1. Let _expected_ be ? ToBigInt(_expectedValue_).
          1. Let _replacement_ be ? ToBigInt(_replacementValue_).
        1. Else,
          1. Let _expected_ be 𝔽(? ToIntegerOrInfinity(_expectedValue_)).
          1. Let _replacement_ be 𝔽(? ToIntegerOrInfinity(_replacementValue_)).
        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).
        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
        1. Let _expectedBytes_ be NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_).
        1. Let _replacementBytes_ be NumericToRawBytes(_elementType_, _replacement_, _isLittleEndian_).
        1. If IsSharedArrayBuffer(_buffer_) is *true*, then
          1. Let _rawBytesRead_ be AtomicCompareExchangeInSharedBlock(_block_, _byteIndexInBuffer_, _elementSize_, _expectedBytes_, _replacementBytes_).
        1. Else,
          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndexInBuffer_].
          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then
            1. Store the individual bytes of _replacementBytes_ into _block_, starting at _block_[_byteIndexInBuffer_].
        1. Return RawBytesToNumeric(_elementType_, _rawBytesRead_, _isLittleEndian_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.exchange-struct">
      <h1>Atomics.exchange ( <del>_typedArray_</del><ins>_typedArrayOrStruct_</ins>, <del>_index_</del><ins>_indexOrField_</ins>, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. Let _second_ be a new read-modify-write modification function with parameters (<del>_oldBytes_</del><ins>_oldValue_</ins>, <del>_newBytes_</del><ins>_newValue_</ins>) that captures nothing and performs the following steps atomically when called:
          1. Return <del>_newBytes_</del><ins>_newValue_</ins>.
        1. <ins>If _typedArrayOrStruct is a Shared Struct, then</ins>
          1. <ins>Return ? AtomicReadModifyWriteInSharedStruct(_typedArrayOrStruct_, _indexOrField_, _value_, _second_).</ins>
        1. <ins>Let _typedArray_ be _typedArrayOrStruct_.</ins>
        1. <ins>Let _index_ be _indexOrField_.</ins>
        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _second_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.load-struct">
      <h1>Atomics.load ( <del>_typedArray_</del><ins>_typedArrayOrStruct_</ins>, <del>_index_</del><ins>_indexOrField_</ins> )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. <ins>If _typedArrayOrStruct_ is a Shared Struct, then</ins>
          1. <ins>If _indexOrField_ is not a property key, throw a *TypeError* exception.</ins>
          1. <ins>If _typedArrayOrStruct_ does not have an own property with key _indexOrField_, throw a *RangeError* exception.</ins>
          1. <ins>Return ReadSharedStructField(_typedArrayOrStruct_, _indexOrField_, ~seq-cst~).</ins>
        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Return GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.store-struct">
      <h1>Atomics.store ( <del>_typedArray_</del><ins>_typedArrayOrStruct_</ins>, <del>_index_</del><ins>_indexOrField_</ins>, _value_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. <ins>If _typedArrayOrStruct_ is a Shared Struct, then</ins>
          1. <ins>If _indexOrField_ is not a property key, throw a *TypeError* exception.</ins>
          1. <ins>If CanBeSharedAcrossAgents(_value_) is *false*, throw a *TypeError* exception.</ins>
          1. <ins>If _typedArrayOrStruct_ does not have an own property with key _indexOrField_, throw a *RangeError* exception.</ins>
          1. <ins>Perform WriteSharedStructField(_typedArrayOrStruct_, _indexOrField_, _value_, ~seq-cst~).</ins>
          1. <ins>Return _value_.</ins>
        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).
        1. If _typedArray_.[[ContentType]] is ~bigint~, let _v_ be ? ToBigInt(_value_).
        1. Otherwise, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).
        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. Let _elementType_ be TypedArrayElementType(_typedArray_).
        1. Perform SetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, *true*, ~seq-cst~).
        1. Return _v_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-changes-to-memory-model">
    <h1>Changes to the Memory Model</h1>
    <emu-clause id="sec-memory-model-fundamentals">
      <h1>Memory Model Fundamentals</h1>
      <p>Shared memory accesses (reads and writes) are divided into two groups, atomic accesses and data accesses, defined below. Atomic accesses are sequentially consistent, i.e., there is a strict total ordering of events agreed upon by all agents in an agent cluster. Non-atomic accesses do not have a strict total ordering agreed upon by all agents, i.e., unordered.</p>
      <emu-note>
        <p>No orderings weaker than sequentially consistent and stronger than unordered, such as release-acquire, are supported.</p>
      </emu-note>
      <ins class="block">
      <p>A <dfn variants="Shared Memory Storage Records">Shared Memory Storage Record</dfn> is either a <dfn>SharedBlockStorage</dfn> or <dfn>SharedStructStorage</dfn> Record.</p>

      <emu-table id="table-sharedblockstorage-fields" caption="SharedBlockStorage Fields">
        <table>
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[Block]]</td>
              <td>a Shared Data Block</td>
              <td>The block the event operates on.</td>
            </tr>
            <tr>
              <td>[[ByteIndex]]</td>
              <td>a non-negative integer</td>
              <td>The byte address of the access in [[Block]].</td>
            </tr>
            <tr>
              <td>[[ElementSize]]</td>
              <td>a non-negative integer</td>
              <td>The size of the access.</td>
            </tr>
          </thead>
        </table>
      </emu-table>

      <emu-table id="table-sharedstructstorage-fields" caption="SharedStructStorage Fields">
        <table>
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[Struct]]</td>
              <td>a Shared Struct</td>
              <td>The shared struct the event operates on.</td>
            </tr>
            <tr>
              <td>[[Field]]</td>
              <td>a property key</td>
              <td>The field that is accessed in [[Struct]].</td>
            </tr>
          </thead>
        </table>
      </emu-table>
      </ins>

      <p>A <dfn variants="Shared Data Block events">Shared Data Block event</dfn> is either a <dfn>ReadSharedMemory</dfn>, <dfn>WriteSharedMemory</dfn>, or <dfn>ReadModifyWriteSharedMemory</dfn> Record.</p>

      <emu-table id="table-readsharedmemory-fields" caption="ReadSharedMemory Event Fields">
        <table>
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
          </thead>
          <tr>
            <td>[[Order]]</td>
            <td>~seq-cst~ or ~unordered~</td>
            <td>The weakest ordering guaranteed by the memory model for the event.</td>
          </tr>
          <tr>
            <td>[[NoTear]]</td>
            <td>a Boolean</td>
            <td>Whether this event is allowed to read from multiple write events with equal range as this event.</td>
          </tr>
          <tr>
            <td><del>[[Block]]</del></td>
            <td><del>a Shared Data Block</del></td>
            <td><del>The block the event operates on.</del></td>
          </tr>
          <tr>
            <td><del>[[ByteIndex]]</del></td>
            <td><del>a non-negative integer</del></td>
            <td><del>The byte address of the read in [[Block]].</del></td>
          </tr>
          <tr>
            <td><del>[[ElementSize]]</del></td>
            <td><del>a non-negative integer</del></td>
            <td><del>The size of the read.</del></td>
          </tr>
          <tr>
            <td><ins>[[Storage]]</ins></td>
            <td><ins>a Shared Memory Storage Record</ins></td>
            <td><ins>The storage of memory that is read.</ins></td>
          </tr>
        </table>
      </emu-table>

      <emu-table id="table-writesharedmemory-fields" caption="WriteSharedMemory Event Fields">
        <table>
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
          </thead>
          <tr>
            <td>[[Order]]</td>
            <td>~seq-cst~, ~unordered~, or ~init~</td>
            <td>The weakest ordering guaranteed by the memory model for the event.</td>
          </tr>
          <tr>
            <td>[[NoTear]]</td>
            <td>a Boolean</td>
            <td>Whether this event is allowed to be read from multiple read events with equal range as this event.</td>
          </tr>
          <tr>
            <td><del>[[Block]]</del></td>
            <td><del>a Shared Data Block</del></td>
            <td><del>The block the event operates on.</del></td>
          </tr>
          <tr>
            <td><del>[[ByteIndex]]</del></td>
            <td><del>a non-negative integer</del></td>
            <td><del>The byte address of the write in [[Block]].</del></td>
          </tr>
          <tr>
            <td><del>[[ElementSize]]</del></td>
            <td><del>a non-negative integer</del></td>
            <td><del>The size of the write.</del></td>
          </tr>
          <tr>
            <td><ins>[[Storage]]</ins></td>
            <td><ins>a Shared Memory Storage Record</ins></td>
            <td><ins>The storage of memory that is written.</ins></td>
          </tr>
          <tr>
            <td>[[Payload]]</td>
            <td>a List of byte values</td>
            <td>The List of byte values to be read by other events.</td>
          </tr>
        </table>
      </emu-table>

      <emu-table id="table-rmwsharedmemory-fields" caption="ReadModifyWriteSharedMemory Event Fields">
        <table>
          <thead>
            <tr>
              <th>Field Name</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
          </thead>
          <tr>
            <td>[[Order]]</td>
            <td>~seq-cst~</td>
            <td>Read-modify-write events are always sequentially consistent.</td>
          </tr>
          <tr>
            <td>[[NoTear]]</td>
            <td>*true*</td>
            <td>Read-modify-write events cannot tear.</td>
          </tr>
          <tr>
            <td><del>[[Block]]</del></td>
            <td><del>a Shared Data Block</del></td>
            <td><del>The block the event operates on.</del></td>
          </tr>
          <tr>
            <td><del>[[ByteIndex]]</del></td>
            <td><del>a non-negative integer</del></td>
            <td><del>The byte address of the read-modify-write in [[Block]].</del></td>
          </tr>
          <tr>
            <td><del>[[ElementSize]]</del></td>
            <td><del>a non-negative integer</del></td>
            <td><del>The size of the read-modify-write.</del></td>
          </tr>
          <tr>
            <td><ins>[[Storage]]</ins></td>
            <td><ins>a Shared Memory Storage Record</ins></td>
            <td><ins>The storage of memory of the read-modify-write.</ins></td>
          </tr>
          <tr>
            <td>[[Payload]]</td>
            <td>a List of byte values</td>
            <td>The List of byte values to be passed to [[ModifyOp]].</td>
          </tr>
          <tr>
            <td>[[ModifyOp]]</td>
            <td>a read-modify-write modification function</td>
            <td>An abstract closure that returns a modified List of byte values from a read List of byte values and [[Payload]].</td>
          </tr>
        </table>
      </emu-table>

      <p>These events are introduced by abstract operations or by methods on the Atomics object.</p>
      <p>Some operations may also introduce <dfn>Synchronize</dfn> events. A <dfn variants="Synchronize events">Synchronize event</dfn> has no fields, and exists purely to directly constrain the permitted orderings of other events.</p>
      <p>In addition to Shared Data Block and Synchronize events, there are host-specific events.</p>
      <p><ins>If the [[Storage]] field of a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event is a SharedBlockStorage, then </ins><del>L</del><ins>l</ins>et <del>the</del><ins>its</ins> range of <del>a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event</del> be the Set of contiguous integers from its <ins>[[Storage]].</ins>[[ByteIndex]] to <ins>[[Storage]].</ins>[[ByteIndex]] + <ins>[[Storage]].</ins>[[ElementSize]] - 1. Two events' ranges are equal when the events <ins>have a SharedBlockStorage in their [[Storage]] field,</ins> have the same <ins>[[Storage]].</ins>[[Block]], and the ranges are element-wise equal. Two events' ranges are overlapping when the events have the same <ins>[[Storage]].</ins>[[Block]], the ranges are not equal and their intersection is non-empty. Two events' ranges are disjoint when the events do not <ins>both have a SharedBlockStorage in their [[Storage]] field, do not</ins> have the same <ins>[[Storage]].</ins>[[Block]]<ins>,</ins> or their ranges are neither equal nor overlapping.</p>
      <p><ins>If the [[Storage]] field of a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event is a SharedStructStorage, then let its range be the value of the [[Storage]] field. Two events' ranges are equal when the events have a SharedStructStorage in their [[Storage]] field, have the same [[Storage]].[[Struct]] and the same [[Storage]].[[Field]]. Two events' ranges that both have a SharedStructStorage in their [[Storage]] field are never overlapping. Two events' ranges are disjoint when the events do not both have a SharedStructStorage in their [[Storage]] Field, or do not have the same [[Storage]].[[Struct]] or the same [[Storage]].[[Field]].</ins></p>
    </emu-clause>
  </emu-clause>
  <p>For brevity, the refactoring of the memory model relations to use SharedStructStorage and the modified definition of event ranges is omitted.</p>
</emu-clause>

<emu-clause id="sec-shared-arrays">
  <h1>Shared Array Object</h1>
  <p><dfn variant="Shared Array">Shared Arrays</dfn> are a special case of Shared Structs with array indexed properties and an immutable *"length"* own property. Since they are Shared Structs, their layout, i.e. their length, is fixed at creation time.</p>

  <ins class="block">
  <emu-clause id="sec-shared-array-constructor">
    <h1>The SharedArray Constructor</h1>
    <p>The SharedArray constructor:</p>
    <ul>
      <li>is <dfn>%SharedArray%</dfn>.</li>
      <li>is the initial value of the *"SharedArray"* property of the global object.</li>
      <li>creates and initializes a new Shared Array when called as a constructor.</li>
      <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
      <li>is a function whose behaviour differs based upon the number and types of its arguments.</li>
    </ul>

    <emu-clause id="sec-sharedarraycreate" type="abstract operation">
      <h1>
        SharedArrayCreate (
          _length_: an non-negative integer,
        ): a Shared Array
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It is used to specify the creation of new Shared Arrays.</dd>
      </dl>
      <emu-alg>
        1. Assert: _length_ &le; 2<sup>32</sup> - 1.
        1. Let _createInitializer_ be a new Abstract Closure with parameters (_newSharedArray_) that captures _length_ and performs the following steps when called:
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _length_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Create an own data property named _Pk_ of object _newSharedArray_ whose [[Value]] is *undefined*, [[Writable]] is *true*, [[Enumerable]] is *true*, and [[Configurable]] is *false*.
            1. Perform WriteSharedStructField(_newSharedArray_, _Pk_, *undefined*, ~init~).
          1. Create an own data property named *"length"* of object _newSharedArray_ whose [[Value]] is 𝔽(_length_), [[Writable]] is *false*, [[Enumerable]] is *false*, and [[Configurable]] is *false*.
          1. Perform WriteSharedStructField(_newSharedArray_, *"length"*, 𝔽(_length_), ~init~).
          1. Return ~unused~.
        1. Return SharedStructCreate(_createInitializer_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-sharedarray">
      <h1>SharedArray ( ..._values_ )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. EDITOR'S NOTE: Per-Realm prototypes, which is currently an open design question and not included in this draft, will give Shared Arrays a per-Realm prototype with built-in methods.
        1. Let _numberOfArgs_ be the number of elements in _values_.
        1. If _numberOfArgs_ = 0, then
          1. Return SharedArrayCreate(0).
        1. Else if _numberOfArgs_ = 1, then
          1. Let _len_ be _values_[0].
          1. If _len_ is not an integral Number, throw a *TypeError* exception.
          1. If _len_ &lt; 0, throw a *RangeError* exception.
          1. Let _lenReal_ be ℝ(_len_).
          1. If _lenReal_ > 2<sup>32</sup> - 1, throw a *RangeError* exception.
          1. Return SharedArrayCreate(_lenReal_).
        1. Else,
          1. Assert: _numberOfArgs_ ≥ 2.
          1. Let _array_ be SharedArrayCreate(_numberOfArgs_).
          1. Let _k_ be 0.
          1. Repeat, while _k_ &lt; _numberOfArgs_,
            1. Let _Pk_ be ! ToString(𝔽(_k_)).
            1. Let _itemK_ be _values_[_k_].
            1. Perform ! Set(_array_, _Pk_, _itemK_, *true*).
            1. Set _k_ to _k_ + 1.
          1. Return _array_.
      </emu-alg>
    </emu-clause>
  </emu-clause>
  </ins>
</emu-clause>

<emu-clause id="sec-unsafe-block">
  <h1>The `unsafe` Block</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    BlockStatement[Yield, Await, Return] :
      Block[?Yield, ?Await, ?Return]
      <ins>UnsafeBlock[?Yield, ?Await, ?Return]</ins>

    <ins class="block">
    UnsafeBlock[Yield, Await, Return] :
      `unsafe` [no LineTerminator here] Block[?Yield, ?Await, ?Return]
    </ins>
  </emu-grammar>

  <emu-clause id="sec-isunsafe" type="abstract operation">
    <h1>
      Static Semantics: IsUnsafe (
        _node_: a Parse Node,
      ): a Boolean
    </h1>
    <dl class="header">
    </dl>
    <emu-alg>
      1. If _node_ is contained within an |UnsafeBlock|, return *true*; else return *false*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-unsafe-block-runtime-semantics-evaluation" type="sdo">
    <h1>Runtime Semantics: Evaluation</h1>
    <emu-grammar>UnsafeBlock : `unsafe` Block</emu-grammar>
    <emu-alg>
      1. Return ? Evaluation of |Block|.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-changes-to-reference-records">
    <h1>Changes to Reference Records</h1>

    <emu-clause id="sec-reference-record-specification-type" oldids="sec-reference-specification-type">
      <h1>The Reference Record Specification Type</h1>
      <p>The <dfn variants="Reference Records">Reference Record</dfn> type is used to explain the behaviour of such operators as `delete`, `typeof`, the assignment operators, the `super` keyword and other language features. For example, the left-hand operand of an assignment is expected to produce a Reference Record.</p>
      <p>A Reference Record is a resolved name or property binding; its fields are defined by <emu-xref href="#table-reference-record-fields"></emu-xref>.</p>

      <emu-table id="table-reference-record-fields" caption="Reference Record Fields">
        <table>
          <tr>
            <th>Field Name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td oldids="sec-getbase,ao-getbase">[[Base]]</td>
            <td>an ECMAScript language value, an Environment Record, or ~unresolvable~</td>
            <td>The value or Environment Record which holds the binding. A [[Base]] of ~unresolvable~ indicates that the binding could not be resolved.</td>
          </tr>
          <tr>
            <td oldids="sec-getreferencedname,ao-getreferencedname">[[ReferencedName]]</td>
            <td>a String, a Symbol, or a Private Name</td>
            <td>The name of the binding. Always a String if [[Base]] value is an Environment Record.</td>
          </tr>
          <tr>
            <td oldids="sec-isstrictreference,ao-isstrictreference">[[Strict]]</td>
            <td>a Boolean</td>
            <td>*true* if the Reference Record originated in strict mode code, *false* otherwise.</td>
          </tr>
          <tr>
            <td><ins>[[Unsafe]]</ins></td>
            <td><ins>a Boolean</ins></td>
            <td><ins>*true* if the Reference Record originated in an |UnsafeBlock|, *false* otherwise.</ins></td>
          </tr>
          <tr>
            <td>[[ThisValue]]</td>
            <td>an ECMAScript language value or ~empty~</td>
            <td>If not ~empty~, the Reference Record represents a property binding that was expressed using the `super` keyword; it is called a <dfn id="super-reference-record" oldids="super-reference" variants="Super Reference Records">Super Reference Record</dfn> and its [[Base]] value will never be an Environment Record. In that case, the [[ThisValue]] field holds the *this* value at the time the Reference Record was created.</td>
          </tr>
        </table>
      </emu-table>

      <p>The following abstract operations are used in this specification to operate upon Reference Records:</p>

      <emu-clause id="sec-getvalue" type="abstract operation">
        <h1>
          GetValue (
            _V_: a Reference Record or an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _V_ is not a Reference Record, return _V_.
          1. If IsUnresolvableReference(_V_) is *true*, throw a *ReferenceError* exception.
          1. If IsPropertyReference(_V_) is *true*, then
            1. [id="step-getvalue-toobject"] Let _baseObj_ be ? ToObject(_V_.[[Base]]).
            1. If IsPrivateReference(_V_) is *true*, then
              1. Return ? PrivateGet(_baseObj_, _V_.[[ReferencedName]]).
            1. <del>Return ? <emu-meta effects="user-code">_baseObj_.[[Get]]</emu-meta>(_V_.[[ReferencedName]], GetThisValue(_V_)).</del>
            1. <ins>If _V_.[[Unsafe]] is *true*, then</ins>
              1. <ins>Return ? <emu-meta effects="user-code">_baseObj_.[[UnsafeGet]]</emu-meta>(_V_.[[ReferencedName]], GetThisValue(_V_)).</ins>
            1. <ins>Else,</ins>
              1. <ins>Return ? <emu-meta effects="user-code">_baseObj_.[[Get]]</emu-meta>(_V_.[[ReferencedName]], GetThisValue(_V_)).</ins>
          1. Else,
            1. Let _base_ be _V_.[[Base]].
            1. Assert: _base_ is an Environment Record.
            1. Return ? <emu-meta effects="user-code">_base_.GetBindingValue</emu-meta>(_V_.[[ReferencedName]], _V_.[[Strict]]) (see <emu-xref href="#sec-environment-records"></emu-xref>).
        </emu-alg>
        <emu-note>
          <p>The object that may be created in step <emu-xref href="#step-getvalue-toobject"></emu-xref> is not accessible outside of the above abstract operation and the ordinary object [[Get]] internal method. An implementation might choose to avoid the actual creation of the object.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-putvalue" type="abstract operation">
        <h1>
          PutValue (
            _V_: a Reference Record or an ECMAScript language value,
            _W_: an ECMAScript language value,
          ): either a normal completion containing ~unused~ or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. If _V_ is not a Reference Record, throw a *ReferenceError* exception.
          1. If IsUnresolvableReference(_V_) is *true*, then
            1. If _V_.[[Strict]] is *true*, throw a *ReferenceError* exception.
            1. Let _globalObj_ be GetGlobalObject().
            1. Perform ? Set(_globalObj_, _V_.[[ReferencedName]], _W_, *false*).
            1. Return ~unused~.
          1. If IsPropertyReference(_V_) is *true*, then
            1. [id="step-putvalue-toobject"] Let _baseObj_ be ? ToObject(_V_.[[Base]]).
            1. If IsPrivateReference(_V_) is *true*, then
              1. Return ? PrivateSet(_baseObj_, _V_.[[ReferencedName]], _W_).
            1. <del>Let _succeeded_ be ? <emu-meta effects="user-code">_baseObj_.[[Set]]</emu-meta>(_V_.[[ReferencedName]], _W_, GetThisValue(_V_)).</del>
            1. <ins>If _V_.[[Unsafe]] is *true*, then</ins>
              1. <ins>Let _succeeded_ be ? <emu-meta effects="user-code">_baseObj_.[[UnsafeSet]]</emu-meta>(_V_.[[ReferencedName]], _W_, GetThisValue(_V_)).</ins>
            1. <ins>Else,</ins>
              1. <ins>Let _succeeded_ be ? <emu-meta effects="user-code">_baseObj_.[[Set]]</emu-meta>(_V_.[[ReferencedName]], _W_, GetThisValue(_V_)).</ins>
            1. If _succeeded_ is *false* and _V_.[[Strict]] is *true*, throw a *TypeError* exception.
            1. Return ~unused~.
          1. Else,
            1. Let _base_ be _V_.[[Base]].
            1. Assert: _base_ is an Environment Record.
            1. Return ? <emu-meta effects="user-code">_base_.SetMutableBinding</emu-meta>(_V_.[[ReferencedName]], _W_, _V_.[[Strict]]) (see <emu-xref href="#sec-environment-records"></emu-xref>).
        </emu-alg>
        <emu-note>
          <p>The object that may be created in step <emu-xref href="#step-putvalue-toobject"></emu-xref> is not accessible outside of the above abstract operation and the ordinary object [[Set]] internal method. An implementation might choose to avoid the actual creation of that object.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-changes-to-ordinary-and-exotic-objects-behaviours">
    <h1>Changes to Ordinary and Exotic Objects Behaviours</h1>
    <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots">
      <h1>Ordinary Object Internal Methods and Internal Slots</h1>

      <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
        <h1>
          [[Get]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>an ordinary object _O_</dd>
        </dl>

        <emu-alg>
          1. Return ? OrdinaryGet(_O_, _P_, _Receiver_<ins>, *false*</ins>).
        </emu-alg>

        <emu-clause id="sec-ordinaryget" type="abstract operation">
          <h1>
            OrdinaryGet (
              _O_: an Object,
              _P_: a property key,
              _Receiver_: an ECMAScript language value,
              <ins>_unsafe_: a Boolean,</ins>
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
          </dl>

          <emu-alg>
            1. Let _desc_ be ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_).
            1. If _desc_ is *undefined*, then
              1. Let _parent_ be ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>().
              1. If _parent_ is *null*, return *undefined*.
              1. <del>Return ? <emu-meta effects="user-code">_parent_.[[Get]]</emu-meta>(_P_, _Receiver_).</del>
              1. <ins>If _unsafe_ is *true*, then</ins>
                1. <ins>Return ? <emu-meta effects="user-code">_parent_.[[UnsafeGet]]</emu-meta>(_P_, _Receiver_).</ins>
              1. <ins>Else,</ins>
                1. <ins>Return ? <emu-meta effects="user-code">_parent_.[[Get]]</emu-meta>(_P_, _Receiver_).</ins>
            1. If IsDataDescriptor(_desc_) is *true*, return _desc_.[[Value]].
            1. Assert: IsAccessorDescriptor(_desc_) is *true*.
            1. Let _getter_ be _desc_.[[Get]].
            1. If _getter_ is *undefined*, return *undefined*.
            1. Return ? Call(_getter_, _Receiver_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
        <h1>
          [[Set]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>an ordinary object _O_</dd>
        </dl>
        <emu-alg>
          1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_<ins>, *false*</ins>).
        </emu-alg>

        <emu-clause id="sec-ordinaryset" type="abstract operation">
          <h1>
            OrdinarySet (
              _O_: an Object,
              _P_: a property key,
              _V_: an ECMAScript language value,
              _Receiver_: an ECMAScript language value,
              <ins>_unsafe_: a Boolean,</ins>
            ): either a normal completion containing a Boolean or a throw completion
          </h1>
          <dl class="header">
          </dl>

          <emu-alg>
            1. Let _ownDesc_ be ? <emu-meta effects="user-code">_O_.[[GetOwnProperty]]</emu-meta>(_P_).
            1. Return ? OrdinarySetWithOwnDescriptor(_O_, _P_, _V_, _Receiver_, _ownDesc_<ins>, _unsafe_</ins>).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-ordinarysetwithowndescriptor" type="abstract operation">
          <h1>
            OrdinarySetWithOwnDescriptor (
              _O_: an Object,
              _P_: a property key,
              _V_: an ECMAScript language value,
              _Receiver_: an ECMAScript language value,
              _ownDesc_: a Property Descriptor or *undefined*,
              <ins>_unsafe_: a Boolean,</ins>
            ): either a normal completion containing a Boolean or a throw completion
          </h1>
          <dl class="header">
          </dl>

          <emu-alg>
            1. If _ownDesc_ is *undefined*, then
              1. Let _parent_ be ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]</emu-meta>().
              1. If _parent_ is not *null*, then
                1. <del>Return ? <emu-meta effects="user-code">_parent_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_).</del>
                1. <ins>If _unsafe_ is *true*, then</ins>
                  1. <ins>Return ? <emu-meta effects="user-code">_parent_.[[UnsafeSet]]</emu-meta>(_P_, _V_, _Receiver_).</ins>
                1. <ins>Else,</ins>
                  1. <ins>Return ? <emu-meta effects="user-code">_parent_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_).</ins>
              1. Else,
                1. Set _ownDesc_ to the PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.
            1. If IsDataDescriptor(_ownDesc_) is *true*, then
              1. If _ownDesc_.[[Writable]] is *false*, return *false*.
              1. If _Receiver_ is not an Object, return *false*.
              1. Let _existingDescriptor_ be ? <emu-meta effects="user-code">_Receiver_.[[GetOwnProperty]]</emu-meta>(_P_).
              1. If _existingDescriptor_ is not *undefined*, then
                1. If IsAccessorDescriptor(_existingDescriptor_) is *true*, return *false*.
                1. If _existingDescriptor_.[[Writable]] is *false*, return *false*.
                1. Let _valueDesc_ be the PropertyDescriptor { [[Value]]: _V_ }.
                1. Return ? <emu-meta effects="user-code">_Receiver_.[[DefineOwnProperty]]</emu-meta>(_P_, _valueDesc_).
              1. Else,
                1. Assert: _Receiver_ does not currently have a property _P_.
                1. Return ? CreateDataProperty(_Receiver_, _P_, _V_).
            1. Assert: IsAccessorDescriptor(_ownDesc_) is *true*.
            1. Let _setter_ be _ownDesc_.[[Set]].
            1. If _setter_ is *undefined*, return *false*.
            1. Perform ? Call(_setter_, _Receiver_, « _V_ »).
            1. Return *true*.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <ins class="block">
      <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-unsafeget-p-receiver" type="internal method">
        <h1>
          [[UnsafeGet]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>an ordinary object _O_</dd>
        </dl>

        <emu-alg>
          1. Return ? OrdinaryGet(O, P, _Receiver_, *true*).
        </emu-alg>
      </emu-clause>
      </ins>

      <ins class="block">
      <emu-clause id="sec-ordinary-object-internal-methods-and-internal-slots-unsafeset-p-v-receiver" type="internal method">
        <h1>
          [[UnsafeSet]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>an ordinary object _O_</dd>
        </dl>
        <emu-alg>
          1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_, *true*).
        </emu-alg>
      </emu-clause>
      </ins>
    </emu-clause>

    <emu-clause id="sec-built-in-exotic-object-internal-methods-and-slots">
      <h1>Built-in Exotic Object Internal Methods and Slots</h1>
      <emu-clause id="sec-arguments-exotic-objects">
        <h1>Arguments Exotic Objects</h1>
        <emu-clause id="sec-arguments-exotic-objects-get-p-receiver" type="internal method">
          <h1>
            [[Get]] (
              _P_: a property key,
              _Receiver_: an ECMAScript language value,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>an arguments exotic object _args_</dd>
          </dl>
          <emu-alg>
            1. Let _map_ be _args_.[[ParameterMap]].
            1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).
            1. If _isMapped_ is *false*, then
              1. Return ? OrdinaryGet(_args_, _P_, _Receiver_<ins>, *false*</ins>).
            1. Else,
              1. Assert: _map_ contains a formal parameter mapping for _P_.
              1. Return ! Get(_map_, _P_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-arguments-exotic-objects-set-p-v-receiver" type="internal method">
          <h1>
            [[Set]] (
              _P_: a property key,
              _V_: an ECMAScript language value,
              _Receiver_: an ECMAScript language value,
            ): either a normal completion containing a Boolean or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>an arguments exotic object _args_</dd>
          </dl>
          <emu-alg>
            1. If SameValue(_args_, _Receiver_) is *false*, then
              1. Let _isMapped_ be *false*.
            1. Else,
              1. Let _map_ be _args_.[[ParameterMap]].
              1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).
            1. If _isMapped_ is *true*, then
              1. Assert: The following Set will succeed, since formal parameters mapped by arguments objects are always writable.
              1. Perform ! Set(_map_, _P_, _V_, *false*).
            1. Return ? OrdinarySet(_args_, _P_, _V_, _Receiver_<ins>, *false*</ins>).
          </emu-alg>
        </emu-clause>

        <ins class="block">
        <emu-clause id="sec-arguments-exotic-objects-unsafeget-p-receiver" type="internal method">
          <h1>
            [[UnsafeGet]] (
              _P_: a property key,
              _Receiver_: an ECMAScript language value,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>an arguments exotic object _args_</dd>
          </dl>
          <emu-alg>
            1. Let _map_ be _args_.[[ParameterMap]].
            1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).
            1. If _isMapped_ is *false*, then
              1. Return ? OrdinaryGet(_args_, _P_, _Receiver_<ins>, *true*</ins>).
            1. Else,
              1. Assert: _map_ contains a formal parameter mapping for _P_.
              1. Return ! Get(_map_, _P_).
          </emu-alg>
        </emu-clause>
        </ins>

        <ins class="block">
        <emu-clause id="sec-arguments-exotic-objects-unsafeset-p-v-receiver" type="internal method">
          <h1>
            [[UnsafeSet]] (
              _P_: a property key,
              _V_: an ECMAScript language value,
              _Receiver_: an ECMAScript language value,
            ): either a normal completion containing a Boolean or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>an arguments exotic object _args_</dd>
          </dl>
          <emu-alg>
            1. If SameValue(_args_, _Receiver_) is *false*, then
              1. Let _isMapped_ be *false*.
            1. Else,
              1. Let _map_ be _args_.[[ParameterMap]].
              1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).
            1. If _isMapped_ is *true*, then
              1. Assert: The following Set will succeed, since formal parameters mapped by arguments objects are always writable.
              1. Perform ! Set(_map_, _P_, _V_, *false*).
            1. Return ? OrdinarySet(_args_, _P_, _V_, _Receiver_<ins>, *true*</ins>).
          </emu-alg>
        </emu-clause>
        </ins>
      </emu-clause>

      <emu-clause id="sec-typedarray-exotic-objects" oldids="sec-integer-indexed-exotic-objects">
        <h1>TypedArray Exotic Objects</h1>
        <emu-clause id="sec-typedarray-get" oldids="sec-integer-indexed-exotic-objects-get-p-receiver" type="internal method">
          <h1>
            [[Get]] (
              _P_: a property key,
              _Receiver_: an ECMAScript language value,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a TypedArray _O_</dd>
          </dl>
          <emu-alg>
            1. If _P_ is a String, then
              1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).
              1. If _numericIndex_ is not *undefined*, then
                1. Return TypedArrayGetElement(_O_, _numericIndex_).
            1. Return ? OrdinaryGet(_O_, _P_, _Receiver_<ins>, *false*</ins>).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-typedarray-set" oldids="sec-integer-indexed-exotic-objects-set-p-v-receiver" type="internal method">
          <h1>
            [[Set]] (
              _P_: a property key,
              _V_: an ECMAScript language value,
              _Receiver_: an ECMAScript language value,
            ): either a normal completion containing a Boolean or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a TypedArray _O_</dd>
          </dl>
          <emu-alg>
            1. If _P_ is a String, then
              1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).
              1. If _numericIndex_ is not *undefined*, then
                1. If SameValue(_O_, _Receiver_) is *true*, then
                  1. Perform ? TypedArraySetElement(_O_, _numericIndex_, _V_).
                  1. Return *true*.
                1. If IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *true*.
            1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_<ins>, *false*</ins>).
          </emu-alg>
        </emu-clause>

        <ins class="block">
        <emu-clause id="sec-typedarray-unsafeget" type="internal method">
          <h1>
            [[UnsafeGet]] (
              _P_: a property key,
              _Receiver_: an ECMAScript language value,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a TypedArray _O_</dd>
          </dl>
          <emu-alg>
            1. If _P_ is a String, then
              1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).
              1. If _numericIndex_ is not *undefined*, then
                1. Return TypedArrayGetElement(_O_, _numericIndex_).
            1. Return ? OrdinaryGet(_O_, _P_, _Receiver_<ins>, *true*</ins>).
          </emu-alg>
        </emu-clause>
        </ins>

        <ins class="block">
        <emu-clause id="sec-typedarray-unsafeset" type="internal method">
          <h1>
            [[UnsafeSet]] (
              _P_: a property key,
              _V_: an ECMAScript language value,
              _Receiver_: an ECMAScript language value,
            ): either a normal completion containing a Boolean or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a TypedArray _O_</dd>
          </dl>
          <emu-alg>
            1. If _P_ is a String, then
              1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).
              1. If _numericIndex_ is not *undefined*, then
                1. If SameValue(_O_, _Receiver_) is *true*, then
                  1. Perform ? TypedArraySetElement(_O_, _numericIndex_, _V_).
                  1. Return *true*.
                1. If IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *true*.
            1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_<ins>, *true*</ins>).
          </emu-alg>
        </emu-clause>
        </ins>
      </emu-clause>

      <emu-clause id="sec-module-namespace-exotic-objects">
        <h1>Module Namespace Exotic Objects</h1>
        <emu-clause id="sec-module-namespace-exotic-objects-get-p-receiver" type="internal method">
          <h1>
            [[Get]] (
              _P_: a property key,
              _Receiver_: an ECMAScript language value,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a module namespace exotic object _O_</dd>
          </dl>
          <emu-alg>
            1. If _P_ is a Symbol, then
              1. Return ! OrdinaryGet(_O_, _P_, _Receiver_<ins>, *false*</ins>).
            1. Let _exports_ be _O_.[[Exports]].
            1. If _exports_ does not contain _P_, return *undefined*.
            1. Let _m_ be _O_.[[Module]].
            1. Let _binding_ be _m_.ResolveExport(_P_).
            1. Assert: _binding_ is a ResolvedBinding Record.
            1. Let _targetModule_ be _binding_.[[Module]].
            1. Assert: _targetModule_ is not *undefined*.
            1. If _binding_.[[BindingName]] is ~namespace~, then
              1. Return GetModuleNamespace(_targetModule_).
            1. Let _targetEnv_ be _targetModule_.[[Environment]].
            1. If _targetEnv_ is ~empty~, throw a *ReferenceError* exception.
            1. Return ? _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*).
          </emu-alg>
          <emu-note>
            <p>ResolveExport is side-effect free. Each time this operation is called with a specific _exportName_, _resolveSet_ pair as arguments it must return the same result. An implementation might choose to pre-compute or cache the ResolveExport results for the [[Exports]] of each module namespace exotic object.</p>
          </emu-note>
        </emu-clause>

        <ins class="block">
        <emu-clause id="sec-module-namespace-exotic-objects-unsafeget-p-receiver" type="internal method">
          <h1>
            [[UnsafeGet]] (
              _P_: a property key,
              _Receiver_: an ECMAScript language value,
            ): either a normal completion containing an ECMAScript language value or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a module namespace exotic object _O_</dd>
          </dl>
          <emu-alg>
            1. If _P_ is a Symbol, then
              1. Return ! OrdinaryGet(_O_, _P_, _Receiver_<ins>, *true*</ins>).
            1. Return ? O.[[Get]](_P_, _Receiver_).
          </emu-alg>
        </emu-clause>
        </ins>

        <ins class="block">
        <emu-clause id="sec-module-namespace-exotic-objects-unsafeset-p-v-receiver" type="internal method">
          <h1>
            [[UnsafeSet]] (
              _P_: a property key,
              _V_: an ECMAScript language value,
              _Receiver_: an ECMAScript language value,
            ): a normal completion containing *false*
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a module namespace exotic object</dd>
          </dl>
          <emu-alg>
            1. Return *false*.
          </emu-alg>
        </emu-clause>
        </ins>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots">
      <h1>Proxy Object Internal Methods and Internal Slots</h1>
      <p>A Proxy object is an exotic object whose essential internal methods are partially implemented using ECMAScript code. Every Proxy object has an internal slot called [[ProxyHandler]]. The value of [[ProxyHandler]] is an object, called the proxy's <em>handler object</em>, or *null*. Methods (see <emu-xref href="#table-proxy-handler-methods"></emu-xref>) of a handler object may be used to augment the implementation for one or more of the Proxy object's internal methods. Every Proxy object also has an internal slot called [[ProxyTarget]] whose value is either an object or the *null* value. This object is called the proxy's <em>target object</em>.</p>

      <p>An object is a <dfn id="proxy-exotic-object" variants="Proxy exotic objects">Proxy exotic object</dfn> if its essential internal methods (including [[Call]] and [[Construct]], if applicable) use the definitions in this section. These internal methods are installed in ProxyCreate.</p>

      <emu-table id="table-proxy-handler-methods" caption="Proxy Handler Methods" oldids="table-30">
        <table>
          <tr>
            <th>
              Internal Method
            </th>
            <th>
              Handler Method
            </th>
          </tr>
          <tr>
            <td>
              [[GetPrototypeOf]]
            </td>
            <td>
              `getPrototypeOf`
            </td>
          </tr>
          <tr>
            <td>
              [[SetPrototypeOf]]
            </td>
            <td>
              `setPrototypeOf`
            </td>
          </tr>
          <tr>
            <td>
              [[IsExtensible]]
            </td>
            <td>
              `isExtensible`
            </td>
          </tr>
          <tr>
            <td>
              [[PreventExtensions]]
            </td>
            <td>
              `preventExtensions`
            </td>
          </tr>
          <tr>
            <td>
              [[GetOwnProperty]]
            </td>
            <td>
              `getOwnPropertyDescriptor`
            </td>
          </tr>
          <tr>
            <td>
              [[DefineOwnProperty]]
            </td>
            <td>
              `defineProperty`
            </td>
          </tr>
          <tr>
            <td>
              [[HasProperty]]
            </td>
            <td>
              `has`
            </td>
          </tr>
          <tr>
            <td>
              <ins>[[UnsafeGet]]</ins>
            </td>
            <td>
              <ins>`get`</ins>
            </td>
          </tr>
          <tr>
            <td>
              [[Get]]
            </td>
            <td>
              `get`
            </td>
          </tr>
          <tr>
            <td>
              <ins>[[UnsafeSet]]</ins>
            </td>
            <td>
              <ins>`set`</ins>
            </td>
          </tr>
          <tr>
            <td>
              [[Set]]
            </td>
            <td>
              `set`
            </td>
          </tr>
          <tr>
            <td>
              [[Delete]]
            </td>
            <td>
              `deleteProperty`
            </td>
          </tr>
          <tr>
            <td>
              [[OwnPropertyKeys]]
            </td>
            <td>
              `ownKeys`
            </td>
          </tr>
          <tr>
            <td>
              [[Call]]
            </td>
            <td>
              `apply`
            </td>
          </tr>
          <tr>
            <td>
              [[Construct]]
            </td>
            <td>
              `construct`
            </td>
          </tr>
        </table>
      </emu-table>

      <ins class="block">
      <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver" type="internal method">
        <h1>
          [[UnsafeGet]] (
            _P_: a property key,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing an ECMAScript language value or a throw completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>a Proxy exotic object _O_</dd>
        </dl>
        <emu-alg>
          1. Perform ? ValidateNonRevokedProxy(_O_).
          1. Let _target_ be _O_.[[ProxyTarget]].
          1. Let _handler_ be _O_.[[ProxyHandler]].
          1. Assert: _handler_ is an Object.
          1. Let _trap_ be ? GetMethod(_handler_, *"get"*).
          1. If _trap_ is *undefined*, then
            1. Return ? <emu-meta effects="user-code">_target_.[[UnsafeGet]]</emu-meta>(_P_, _Receiver_).
          1. Let _trapResult_ be ? Call(_trap_, _handler_, « _target_, _P_, _Receiver_ »).
          1. Let _targetDesc_ be ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_).
          1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then
            1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then
              1. If SameValue(_trapResult_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.
            1. If IsAccessorDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Get]] is *undefined*, then
              1. If _trapResult_ is not *undefined*, throw a *TypeError* exception.
          1. Return _trapResult_.
        </emu-alg>
        <emu-note>
          <p>[[UnsafeGet]] for Proxy objects enforces the following invariants:</p>
          <ul>
            <li>
              The value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable own data property.
            </li>
            <li>
              The value reported for a property must be *undefined* if the corresponding target object property is a non-configurable own accessor property that has *undefined* as its [[Get]] attribute.
            </li>
          </ul>
        </emu-note>
      </emu-clause>
      </ins>

      <ins class="block">
      <emu-clause id="sec-proxy-object-internal-methods-and-internal-slots-set-p-v-receiver" type="internal method">
        <h1>
          [[UnsafeSet]] (
            _P_: a property key,
            _V_: an ECMAScript language value,
            _Receiver_: an ECMAScript language value,
          ): either a normal completion containing a Boolean or a throw completion
        </h1>
        <dl class="header">
          <dt>for</dt>
          <dd>a Proxy exotic object _O_</dd>
        </dl>
        <emu-alg>
          1. Perform ? ValidateNonRevokedProxy(_O_).
          1. Let _target_ be _O_.[[ProxyTarget]].
          1. Let _handler_ be _O_.[[ProxyHandler]].
          1. Assert: _handler_ is an Object.
          1. Let _trap_ be ? GetMethod(_handler_, *"set"*).
          1. If _trap_ is *undefined*, then
            1. Return ? <emu-meta effects="user-code">_target_.[[UnsafeSet]]</emu-meta>(_P_, _V_, _Receiver_).
          1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _V_, _Receiver_ »)).
          1. If _booleanTrapResult_ is *false*, return *false*.
          1. Let _targetDesc_ be ? <emu-meta effects="user-code">_target_.[[GetOwnProperty]]</emu-meta>(_P_).
          1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then
            1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then
              1. If SameValue(_V_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.
            1. If IsAccessorDescriptor(_targetDesc_) is *true*, then
              1. If _targetDesc_.[[Set]] is *undefined*, throw a *TypeError* exception.
          1. Return *true*.
        </emu-alg>
        <emu-note>
          <p>[[UnsafeSet]] for Proxy objects enforces the following invariants:</p>
          <ul>
            <li>
              The result of [[UnsafeSet]] is a Boolean value.
            </li>
            <li>
              Cannot change the value of a property to be different from the value of the corresponding target object property if the corresponding target object property is a non-writable, non-configurable own data property.
            </li>
            <li>
              Cannot set the value of a property if the corresponding target object property is a non-configurable own accessor property that has *undefined* as its [[Set]] attribute.
            </li>
          </ul>
        </emu-note>
      </emu-clause>
      </ins>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-changes-to-ecmascript-language-expressions">
    <h1>Changes to Expressions</h1>
    <emu-clause id="sec-left-hand-side-expressions">
      <h1>Left-Hand-Side Expressions</h1>
      <emu-clause id="sec-property-accessors">
        <h1>Property Accessors</h1>

        <emu-clause id="sec-property-accessors-runtime-semantics-evaluation" type="sdo">
          <h1>Runtime Semantics: Evaluation</h1>
          <emu-grammar>MemberExpression : MemberExpression `[` Expression `]`</emu-grammar>
          <emu-alg>
            1. Let _baseReference_ be ? Evaluation of |MemberExpression|.
            1. Let _baseValue_ be ? GetValue(_baseReference_).
            1. Let _strict_ be IsStrict(this |MemberExpression|).
            1. <ins>Let _unsafe_ be IsUnsafe(this |MemberExpression|).</ins>
            1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_<ins>, _unsafe_</ins>).
          </emu-alg>
          <emu-grammar>MemberExpression : MemberExpression `.` IdentifierName</emu-grammar>
          <emu-alg>
            1. Let _baseReference_ be ? Evaluation of |MemberExpression|.
            1. Let _baseValue_ be ? GetValue(_baseReference_).
            1. Let _strict_ be IsStrict(this |MemberExpression|).
            1. <ins>Let _unsafe_ be IsUnsafe(this |MemberExpression|).</ins>
            1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_<ins>, _unsafe_</ins>).
          </emu-alg>
          <emu-grammar>MemberExpression : MemberExpression `.` PrivateIdentifier</emu-grammar>
          <emu-alg>
            1. Let _baseReference_ be ? Evaluation of |MemberExpression|.
            1. Let _baseValue_ be ? GetValue(_baseReference_).
            1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.
            1. Return MakePrivateReference(_baseValue_, _fieldNameString_).
          </emu-alg>
          <emu-grammar>CallExpression : CallExpression `[` Expression `]`</emu-grammar>
          <emu-alg>
            1. Let _baseReference_ be ? Evaluation of |CallExpression|.
            1. Let _baseValue_ be ? GetValue(_baseReference_).
            1. Let _strict_ be IsStrict(this |CallExpression|).
            1. <ins>Let _unsafe_ be IsUnsafe(this |MemberExpression|).</ins>
            1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_<ins>, _unsafe_</ins>).
          </emu-alg>
          <emu-grammar>CallExpression : CallExpression `.` IdentifierName</emu-grammar>
          <emu-alg>
            1. Let _baseReference_ be ? Evaluation of |CallExpression|.
            1. Let _baseValue_ be ? GetValue(_baseReference_).
            1. Let _strict_ be IsStrict(this |CallExpression|).
            1. <ins>Let _unsafe_ be IsUnsafe(this |MemberExpression|).</ins>
            1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_<ins>, _unsafe_</ins>).
          </emu-alg>
          <emu-grammar>CallExpression : CallExpression `.` PrivateIdentifier</emu-grammar>
          <emu-alg>
            1. Let _baseReference_ be ? Evaluation of |CallExpression|.
            1. Let _baseValue_ be ? GetValue(_baseReference_).
            1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.
            1. Return MakePrivateReference(_baseValue_, _fieldNameString_).
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-evaluate-property-access-with-expression-key" type="abstract operation" oldids="sec-evaluate-expression-key-property-access">
        <h1>
          EvaluatePropertyAccessWithExpressionKey (
            _baseValue_: an ECMAScript language value,
            _expression_: an |Expression| Parse Node,
            _strict_: a Boolean,
            <ins>_unsafe_: a Boolean,</ins>
          ): either a normal completion containing a Reference Record or an abrupt completion
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _propertyNameReference_ be ? Evaluation of _expression_.
          1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).
          1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).
          1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_<ins>, [[Unsafe]]: _unsafe_</ins>, [[ThisValue]]: ~empty~ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-evaluate-property-access-with-identifier-key" type="abstract operation" oldids="sec-evaluate-identifier-key-property-access">
        <h1>
          EvaluatePropertyAccessWithIdentifierKey (
            _baseValue_: an ECMAScript language value,
            _identifierName_: an |IdentifierName| Parse Node,
            _strict_: a Boolean,
            <ins>_unsafe_: a Boolean,</ins>
          ): a Reference Record
        </h1>
        <dl class="header">
        </dl>
        <emu-alg>
          1. Let _propertyNameString_ be the StringValue of _identifierName_.
          1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameString_, [[Strict]]: _strict_<ins>, [[Unsafe]]: _unsafe_</ins>, [[ThisValue]]: ~empty~ }.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-optional-chains">
        <h1>Optional Chains</h1>

        <emu-clause id="sec-optional-chaining-evaluation" type="sdo">
          <h1>Runtime Semantics: Evaluation</h1>

          <emu-clause id="sec-optional-chaining-chain-evaluation" type="sdo">
          <h1>
            Runtime Semantics: ChainEvaluation (
              _baseValue_: an ECMAScript language value,
              _baseReference_: an ECMAScript language value or a Reference Record,
            ): either a normal completion containing either an ECMAScript language value or a Reference Record, or an abrupt completion
          </h1>
          <dl class="header">
          </dl>
          <emu-grammar>OptionalChain : `?.` Arguments</emu-grammar>
          <emu-alg>
            1. Let _thisChain_ be this |OptionalChain|.
            1. Let _tailCall_ be IsInTailPosition(_thisChain_).
            1. Return ? EvaluateCall(_baseValue_, _baseReference_, |Arguments|, _tailCall_).
          </emu-alg>
          <emu-grammar>OptionalChain : `?.` `[` Expression `]`</emu-grammar>
          <emu-alg>
            1. Let _strict_ be IsStrict(this |OptionalChain|).
            1. <ins>Let _unsafe_ be IsUnsafe(this |MemberExpression|).</ins>
            1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_<ins>, _unsafe_</ins>).
          </emu-alg>
          <emu-grammar>OptionalChain : `?.` IdentifierName</emu-grammar>
          <emu-alg>
            1. Let _strict_ be IsStrict(this |OptionalChain|).
            1. <ins>Let _unsafe_ be IsUnsafe(this |MemberExpression|).</ins>
            1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_<ins>, _unsafe_</ins>).
          </emu-alg>
          <emu-grammar>OptionalChain : `?.` PrivateIdentifier</emu-grammar>
          <emu-alg>
            1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.
            1. Return MakePrivateReference(_baseValue_, _fieldNameString_).
          </emu-alg>
          <emu-grammar>OptionalChain : OptionalChain Arguments</emu-grammar>
          <emu-alg>
            1. Let _optionalChain_ be |OptionalChain|.
            1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.
            1. Let _newValue_ be ? GetValue(_newReference_).
            1. Let _thisChain_ be this |OptionalChain|.
            1. Let _tailCall_ be IsInTailPosition(_thisChain_).
            1. Return ? EvaluateCall(_newValue_, _newReference_, |Arguments|, _tailCall_).
          </emu-alg>
          <emu-grammar>OptionalChain : OptionalChain `[` Expression `]`</emu-grammar>
          <emu-alg>
            1. Let _optionalChain_ be |OptionalChain|.
            1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.
            1. Let _newValue_ be ? GetValue(_newReference_).
            1. Let _strict_ be IsStrict(this |OptionalChain|).
            1. <ins>Let _unsafe_ be IsUnsafe(this |MemberExpression|).</ins>
            1. Return ? EvaluatePropertyAccessWithExpressionKey(_newValue_, |Expression|, _strict_<ins>, _unsafe_</ins>).
          </emu-alg>
          <emu-grammar>OptionalChain : OptionalChain `.` IdentifierName</emu-grammar>
          <emu-alg>
            1. Let _optionalChain_ be |OptionalChain|.
            1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.
            1. Let _newValue_ be ? GetValue(_newReference_).
            1. Let _strict_ be IsStrict(this |OptionalChain|).
            1. <ins>Let _unsafe_ be IsUnsafe(this |MemberExpression|).</ins>
            1. Return EvaluatePropertyAccessWithIdentifierKey(_newValue_, |IdentifierName|, _strict_<ins>, _unsafe_</ins>).
          </emu-alg>
          <emu-grammar>OptionalChain : OptionalChain `.` PrivateIdentifier</emu-grammar>
          <emu-alg>
            1. Let _optionalChain_ be |OptionalChain|.
            1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.
            1. Let _newValue_ be ? GetValue(_newReference_).
            1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.
            1. Return MakePrivateReference(_newValue_, _fieldNameString_).
          </emu-alg>
        </emu-clause>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="changes-to-reflection">
    <h1>Changes to Reflection</h1>
    <emu-clause id="sec-reflect-object">
      <h1>The Reflect Object</h1>
      <emu-clause id="sec-reflect.get">
        <h1>Reflect.get ( _target_, _propertyKey_ [ , _receiver_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _target_ is not an Object, throw a *TypeError* exception.
          1. Let _key_ be ? ToPropertyKey(_propertyKey_).
          1. If _receiver_ is not present, then
            1. Set _receiver_ to _target_.
          1. Return ? <emu-meta effects="user-code">_target_.<del>[[Get]]</del><ins>[[UnsafeGet]]</ins></emu-meta>(_key_, _receiver_).
        </emu-alg>
      </emu-clause>
      <emu-clause id="sec-reflect.set">
        <h1>Reflect.set ( _target_, _propertyKey_, _V_ [ , _receiver_ ] )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If _target_ is not an Object, throw a *TypeError* exception.
          1. Let _key_ be ? ToPropertyKey(_propertyKey_).
          1. If _receiver_ is not present, then
            1. Set _receiver_ to _target_.
          1. Return ? <emu-meta effects="user-code">_target_.<del>[[Set]]</del><ins>[[UnsafeSet]]</ins></emu-meta>(_key_, _V_, _receiver_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-synchronization-primitives">
  <h1>Synchronization Primitives</h1>
  <p>Mutexes and condition variables are provided as higher level abstractions, as an easier to use alternative to user-built abstractions on top of Atomics.wait and Atomics.notify. They are Shared Structs with no fields.</p>

  <ins class="block">
  <emu-clause id="sec-abstract-operations-for-mutex">
    <h1>Abstract Operations for Mutex Objects</h1>

    <emu-clause id="sec-unlocktokencreateifneeded" type="abstract operation">
      <h1>
        UnlockTokenCreateIfNeeded (
          _token_: an Object or *undefined*,
          _mutex_: an Object,
        ) : an Object
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: _mutex_ has a [[MutexWaiterList]] internal slot.
        1. If _token_ is *undefined*, then
          1. Set _token_ to OrdinaryObjectCreate(%Atomics.Mutex.UnlockToken.prototype%, « [[LockedMutex]] »).
        1. Else,
          1. Assert: _token_ has a [[LockedMutex]] internal slot.
          1. Assert: _token_.[[LockedMutex]] is ~empty~.
        1. Set _token_.[[LockedMutex]] to _mutex_.
        1. Return _token_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-lockmutex" type="abstract operation">
      <h1>
        LockMutex (
          _mutex_: an Object,
          _tMillis_: a mathematical value,
        ) : ~acquired~ or ~timed-out~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: _mutex_ has a [[MutexWaiterList]] internal slot.
        1. Assert: AgentCanSuspend() is *true*.
        1. Let _WL_ be _mutex_.[[MutexWaiterList]].
        1. Perform EnterCriticalSection(_WL_).
        1. If _mutex_.[[IsLocked]] is *false*, then
          1. Set _mutex_.[[IsLocked]] to *true*.
          1. Perform LeaveCriticalSection(_WL_).
          1. Return ~acquired~.
        1. Let _thisAgent_ be AgentSignifier().
        1. Let _now_ be the time value (UTC) identifying the current time.
        1. Let _additionalTimeout_ be an implementation-defined non-negative mathematical value.
        1. Let _timeoutTime_ be ℝ(_now_) + _tMillis_ + _additionalTimeout_.
        1. NOTE: When _tMillis_ is +∞, _timeoutTime_ is also +∞.
        1. Let _done_ be *false*.
        1. Repeat, while _done_ is *false*,
          1. Let _waiterRecord_ be a new Waiter Record { [[AgentSignifier]]: _thisAgent_, [[PromiseCapability]]: ~blocking~, [[TimeoutTime]]: _timeoutTime_, [[Result]]: *"ok"* }.
          1. Perform AddWaiter(_WL_, _waiterRecord_).
          1. Perform SuspendThisAgent(_WL_, _waiterRecord_).
          1. If _mutex_.[[IsLocked]] is *false*, then
            1. Set _mutex_.[[IsLocked]] to *true*.
            1. Set _waiterRecord_.[[Result]] to *"ok"*.
            1. Set _done_ to *true*.
          1. Else if _waiterRecord_.[[Result]] is *"timed-out"*, then
            1. Set _done_ to *true*.
        1. Perform LeaveCriticalSection(_WL_).
        1. If _waiterRecord_.[[Result]] is *"ok"*, then
          1. Return ~acquired~.
        1. Assert: _waiterRecord_.[[Result]] is *"timed-out"*.
        1. Return ~timed-out~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-unlockmutex" type="abstract operation">
      <h1>
        UnlockMutex (
          _mutex_: an Object,
        ) : ~unused~
      </h1>
      <dl class="header">
      </dl>
      <emu-alg>
        1. Assert: _mutex_ has a [[MutexWaiterList]] internal slot.
        1. Let _WL_ be _mutex_.[[MutexWaiterList]].
        1. Perform EnterCriticalSection(_WL_).
        1. Assert: _mutex_.[[IsLocked]] is *true*.
        1. Set _mutex_.[[IsLocked]] to *false*.
        1. Let _S_ be RemoveWaiters(_WL_, 1).
        1. For each element _W_ of _S_, do
          1. Perform NotifyWaiter(_WL_, _W_).
        1. Perform LeaveCriticalSection(_WL_).
        1. Return ~unused~.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-mutex-object">
    <h1>The Mutex Constructor</h1>
    <p>The Mutex constructor:</p>
    <ul>
      <li>is <dfn>%Atomics.Mutex%</dfn>.</li>
      <li>is the initial value of the *"Mutex"* property of the %Atomics% object.</li>
      <li>creates and initializes a new Mutex when called as constructor.</li>
      <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
    </ul>

    <emu-clause id="sec-atomics.mutex">
      <h1>Atomics.Mutex ( )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _createInitializer_ be a new Abstract Closure with parameters (_newMutex_) that captures nothing and performs the following steps when called:
          1. Set _newMutex_.[[MutexWaiterList]] to a new WaiterList Record.
          1. Set _newMutex_.[[IsLocked]] to *false*.
          1. Return ~unused~.
        1. Return SharedStructCreate(_createInitializer_, « [[MutexWaiterList]], [[IsLocked]] »).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-mutex-constructor">
    <h1>Properties of the Mutex Constructor</h1>
    <p>The Mutex constructor:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      <li>has the following properties:</li>
    </ul>

    <emu-note>
      <p>Per-Realm prototypes, which is currently an open design question and not included in this draft, will give Mutexes a per-Realm prototype with built-in methods instead of static methods, and will also add support for the %Symbol.dispose%.</p>
    </emu-note>

    <emu-clause id="sec-atomics.mutex.unlocktoken-prop">
      <h1>Atomics.Mutex.UnlockToken ( )</h1>
      <p>See <emu-xref href="#sec-atomics.mutex.unlocktoken"></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="sec-atomics.mutex.lock">
      <h1>Atomics.Mutex.lock ( _mutex_ [ , _unlockToken_ [ , _timeout_ ] ] )</h1>
      <p>This function puts the surrounding agent in a wait queue and suspends it until the mutex is unlocked or until the wait times out, returning a String differentiating those cases.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_mutex_, [[MutexWaiterList]]).
        1. If _unlockToken_ not *undefined*, then
          1. Perform ? RequireInternalSlot(_unlockToken_, [[LockedMutex]]).
          1. If _unlockToken_.[[LockedMutex]] is not ~empty~, throw a *TypeError* exception.
        1. If _timeout_ is *undefined*, set _timeout_ to *+∞*<sub>𝔽</sub>.
        1. If _timeout_ is not a Number, throw a *TypeError* exception.
        1. If _timeout_ is either *NaN* or *+∞*<sub>𝔽</sub>, let _tMillis_ be +∞; else if _timeout_ is *-∞*<sub>𝔽</sub>, let _tMillis_ be 0; else let _tMillis_ be max(ℝ(_timeout_), 0).
        1. If AgentCanSuspend() is *false*, throw a *TypeError* exception.
        1. Let _result_ be LockMutex(_mutex_, _tMillis_).
        1. If _result_ is ~acquired~, then
          1. Return UnlockTokenCreateIfNeeded(_unlockToken_, _mutex_).
        1. Else,
          1. Assert: _result_ is ~timed-out~.
          1. Return *"timed-out"*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.mutex.trylock">
      <h1>Atomics.Mutex.tryLock ( _mutex_ [ , _unlockToken_ ] )</h1>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_mutex_, [[MutexWaiterList]]).
        1. If _unlockToken_ not *undefined*, then
          1. Perform ? RequireInternalSlot(_unlockToken_, [[LockedMutex]]).
          1. If _unlockToken_.[[LockedMutex]] is not ~empty~, throw a *TypeError* exception.
        1. Let _WL_ be _mutex_.[[MutexWaiterList]].
        1. Perform EnterCriticalSection(_WL_).
        1. If _mutex_.[[IsLocked]] is *false*, then
          1. Set _mutex_.[[IsLocked]] to *true*.
          1. Let _result_ be UnlockTokenCreateIfNeeded(_unlockToken_, _mutex_).
        1. Else,
          1. Let _result_ be *"already-locked"*.
        1. Perform LeaveCriticalSection(_WL_).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.mutex.withlock">
      <h1>Atomics.Mutex.withLock ( _mutex_, _callback_ [ , _thisArg_ ] )</h1>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_mutex_, [[MutexWaiterList]]).
        1. If IsCallable(_callback_) is *false*, throw a *TypeError* exception.
        1. If AgentCanSuspend() is *false*, throw a *TypeError* exception.
        1. Let _lockResult_ be LockMutex(_mutex_, +∞).
        1. Assert: _lockResult_ is ~acquired~.
        1. Let _callbackResult_ be Completion(Call(_callback_, _thisArg_, « »)).
        1. Perform UnlockMutex(_mutex_).
        1. Return Completion(_callbackResult_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-unlocktoken-objects">
    <h1>UnlockToken Objects</h1>
    <p>An UnlockToken is the unlock capability returned when a Mutex's lock is acquired. It can be reused. An uninitialized UnlockToken can be created by using the Atomics.Mutex.UnlockToken constructor.</p>

    <emu-clause id="sec-unlocktoken-constructor">
      <h1>The UnlockToken Constructor</h1>
      <p>The UnlockToken constructor:</p>
      <ul>
        <li>is <dfn>%Atomics.Mutex.UnlockToken%</dfn>.</li>
        <li>is the initial value of the *"UnlockToken"* property of the %Atomics.Mutex% object.</li>
        <li>creates and initializes a new UnlockToken when called as a constructor.</li>
        <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
      </ul>

      <emu-clause id="sec-atomics.mutex.unlocktoken">
        <h1>Atomics.Mutex.UnlockToken ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _token_ be OrdinaryObjectCreate(%Atomics.Mutex.UnlockToken.prototype%, « [[LockedMutex]] »).
          1. Set _token_.[[LockedMutex]] to ~empty~.
          1. Return _token_.
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-unlocktoken-constructor">
      <h1>Properties of the UnlockToken Constructor</h1>
      <p>The UnlockToken constructor:</p>
      <ul>
        <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-atomics.mutex.unlocktoken.prototype">
        <h1>Atomics.Mutex.UnlockToken.prototype</h1>
        <p>The initial value of `Atomics.Mutex.UnlockToken.prototype` is the UnlockToken prototype object.</p>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-unlocktoken-prototype">
      <h1>Properties of the UnlockToken Prototype Object</h1>
      <p>The <dfn>UnlockToken prototype</dfn> object:</p>
      <ul>
        <li>is <dfn>%Atomics.Mutex.UnlockToken.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
        <li>is an ordinary object.</li>
        <li>does not have a [[LockedMutex]] internal slot.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-get-atomics.mutex.unlocktoken.prototype.locked">
        <h1>get Atomics.Mutex.UnlockToken.prototype.locked</h1>
        <p>`Atomics.Mutex.UnlockToken.locked` is an accessor property whose set accessor is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _token_ be the *this* value.
          1. Perform ? RequireInternalSlot(_token_, [[LockedMutex]]).
          1. If _token_.[[LockedMutex]] is ~empty~, return *false*; else return *true*.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-atomics.mutex.unlocktoken.prototype.unlock">
        <h1>Atomics.Mutex.UnlockToken.prototype.unlock ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Let _token_ be the *this* value.
          1. Perform ? RequireInternalSlot(_token_, [[LockedMutex]]).
          1. Let _mutex_ be _token_.[[LockedMutex]].
          1. If _mutex_ is not ~empty~, then
            1. Set _token_.[[LockedMutex]] to ~empty~.
            1. Perform UnlockMutex(_mutex_).
            1. Return *true*.
          1. Return *false*.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-condition-object">
    <h1>The Condition Constructor</h1>
    <p>The Condition constructor:</p>
    <ul>
      <li>is <dfn>%Atomics.Condition%</dfn>.</li>
      <li>is the initial value of the *"Condition"* property of the %Atomics% object.</li>
      <li>creates and initializes a new Condition when called as constructor.</li>
      <li>is not intended to be called as a function and will throw an exception when called in that manner.</li>
    </ul>

    <emu-clause id="sec-atomics.condition">
      <h1>Atomics.Condition ( )</h1>
      <p>This function performs the following steps when called:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, throw a *TypeError* exception.
        1. Let _createInitializer_ be a new Abstract Closure with parameters (_newCV_) that captures nothing and performs the following steps when called:
          1. Set _newCV_.[[ConditionWaiterList]] to a new WaiterList Record.
          1. Return ~unused~.
        1. Return SharedStructCreate(_createInitializer_, « [[ConditionWaiterList]] »).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-condition-constructor">
    <h1>Properties of the Condition Constructor</h1>
    <p>The Condition constructor:</p>
    <ul>
      <li>has a [[Prototype]] internal slot whose value is %Function.prototype%.</li>
      <li>has the following properties:</li>
    </ul>

    <emu-note>
      <p>Per-Realm prototypes, which is currently an open design question and not included in this draft, will give Conditions a per-Realm prototype with built-in methods instead of static methods.</p>
    </emu-note>

    <emu-clause id="sec-atomics.condition.wait">
      <h1>Atomics.Condition.wait ( _cv_, _mutexUnlockToken_ [ , _timeout_ ] )</h1>
      <p>This function puts the surrounding agent in a wait queue and suspends it until the condition variable is notified or until the wait times out, returning a String differentiating those cases.</p>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_cv_, [[ConditionWaiterList]]).
        1. Perform ? RequireInternalSlot(_mutexUnlockToken_, [[LockedMutex]]).
        1. If _mutexUnlockToken_.[[LockedMutex]] is ~empty~, throw a *TypeError* exception.
        1. If _timeout_ is *undefined*, set _timeout_ to *+∞*<sub>𝔽</sub>.
        1. If _timeout_ is not a Number, throw a *TypeError* exception.
        1. If _timeout_ is either *NaN* or *+∞*<sub>𝔽</sub>, let _tMillis_ be +∞; else if _timeout_ is *-∞*<sub>𝔽</sub>, let _tMillis_ be 0; else let _tMillis_ be max(ℝ(_timeout_), 0).
        1. If AgentCanSuspend() is *false*, throw a *TypeError* exception.
        1. Let _mutex_ be _mutexUnlockToken_.[[LockedMutex]].
        1. Let _WL_ be _cv_.[[ConditionWaiterList]].
        1. Perform EnterCriticalSection(_WL_).
        1. Let _thisAgent_ be AgentSignifier().
        1. Let _now_ be the time value (UTC) identifying the current time.
        1. Let _additionalTimeout_ be an implementation-defined non-negative mathematical value.
        1. Let _timeoutTime_ be ℝ(_now_) + _tMillis_ + _additionalTimeout_.
        1. NOTE: When _tMillis_ is +∞, _timeoutTime_ is also +∞.
        1. Let _waiterRecord_ be a new Waiter Record { [[AgentSignifier]]: _thisAgent_, [[PromiseCapability]]: ~blocking~, [[TimeoutTime]]: _timeoutTime_, [[Result]]: *"ok"* }.
        1. Perform AddWaiter(_WL_, _waiterRecord_).
        1. Perform UnlockMutex(_mutex_).
        1. Perform SuspendThisAgent(_WL_, _waiterRecord_).
        1. Perform LeaveCriticalSection(_WL_).
        1. Perform LockMutex(_mutex_, +∞).
        1. Return _waiterRecord_.[[Result]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-atomics.condition.notify">
      <h1>Atomics.Condition.notify ( _cv_ [ , _count_ ] )</h1>
      <p>It performs the following steps when called:</p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_cv_, [[ConditionWaiterList]]).
        1. If _count_ is *undefined*, set _count_ to *+∞*<sub>𝔽</sub>.
        1. If _count_ is not an integral Number or is not *+∞*<sub>𝔽</sub>, throw a *TypeError* exception.
        1. Let _WL_ be _cv_.[[ConditionWaiterList]].
        1. Perform EnterCriticalSection(_WL_).
        1. Let _S_ be RemoveWaiters(_WL_, ℝ(_count_)).
        1. For each element _W_ of _S_, do
          1. Perform NotifyWaiter(_WL_, _W_).
        1. Perform LeaveCriticalSection(_WL_).
        1. Let _n_ be the number of elements in _S_.
        1. Return 𝔽(_n_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
  </ins>
</emu-clause>
